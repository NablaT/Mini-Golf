<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>OpenNI 1.5.7: Implementing a Generator</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="OpenNILogo.bmp"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">OpenNI 1.5.7
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="index.html">OpenNI Overview</a></li><li class="navelem"><a class="el" href="smpls_n_guides.html">Samples and Guides</a></li><li class="navelem"><a class="el" href="guides.html">Guides for OpenNI Development</a></li><li class="navelem"><a class="el" href="modules_root.html">Creating OpenNI Modules</a></li><li class="navelem"><a class="el" href="modules_node.html">Creating a Node Implementation</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Implementing a Generator </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>If your node implementation is a generator type (i.e., it produces data), you can usually implement it in one of two ways:</p>
<ul>
<li>Active generator - You implement such a node to generate data independently and it generates data in the background. A typical example of a node that you might implement as an active generator is a depth generator node. Since the depth generator node is typically close to the hardware, you might implement it so that it continually reads data from a hardware sensor, at some defined rate, and generates raw depth data at that same rate. In such an implementation, your depth generator node is generating depth data independently, i.e., without being called by code in the application main program.</li>
</ul>
<ul>
<li>Passive generator - processes the data of other nodes that are earlier in the production graph in order to create new data.</li>
</ul>
<p>Although these two models require different implementations, they both fit in OpenNI interfaces.</p>
<dl class="section note"><dt>Note</dt><dd>Currently, OpenNI interfaces do not enable writing active generators, which require data from another generator.</dd></dl>
<p>When a generator has generated new data, it informs OpenNI by raising its 'New Data Available' event. This will cause OpenNI to call its <a class="el" href="classxn_1_1_module_generator.html#a543e11766a86916c78d7065d0f4bb4a8">xn::ModuleGenerator::UpdateData()</a> method in the application main-loop (assuming the application is using one of the <code>WaitXUpdateAll</code> methods). The UpdateData() method is the only place where the node implementation is allowed to update its <em>Last Updated Data</em>. This flow is explained in detail in the following sections.</p>
<h1><a class="anchor" id="modules_gen_state"></a>
The Generating State</h1>
<p>A generator can be in one of two states: Generating state or Non-generating state. When the node is created, it is in Non-generating state. Non-generating state is useful for defining configuration before actually starting to generate new data.</p>
<p>A generator's state can be changed to Generating state by calling its <a class="el" href="classxn_1_1_module_generator.html#a85a3020712a333d3b36a6af137995b40">xn::ModuleGenerator::StartGenerating()</a> method, and can be changed to non-generating by calling its <a class="el" href="classxn_1_1_module_generator.html#a58c065a0b750e8680fb294eedddc6a2c">xn::ModuleGenerator::StopGenerating()</a> method. The generator is responsible for raising the 'Generation Running Changed' event whenever its generating state has changed.</p>
<p>In essence, when in Generating state, the generator constantly generates new data (as defined and limited by the specifications of the physical hardware devices).</p>
<h1><a class="anchor" id="modules_gen_new"></a>
New Data</h1>
<p>When a generator is in Generating state it generates "new" data, meaning new data that the application hasn't received yet. The generator does <em>not</em> simply make newly generated data available as 'new data' as soon as it has generated it. Each generator preserves the content of its application buffer and is not allowed to modify it until the app request new data. When new data is available:</p>
<ul>
<li>The generator must raise its <code>'New Data Available'</code> event, and</li>
<li>When the generator's <a class="el" href="classxn_1_1_module_generator.html#a15485d6f869ea1a807c256b80cba1873">xn::ModuleGenerator::IsNewDataAvailable()</a> method is called it must return TRUE.</li>
</ul>
<p>When the application calls one of the '<code>Wait X Update All</code> methods and is pending, OpenNI waits until any new data arrives, by waiting for the <code>'New Data Available'</code> event to be raised by any generator. Once this event was raised, OpenNI checks if the requested 'wait' condition has now been achieved (either 'All', 'Any', 'One' or 'None' of the nodes has new data) by calling the <a class="el" href="classxn_1_1_module_generator.html#a15485d6f869ea1a807c256b80cba1873">xn::ModuleGenerator::IsNewDataAvailable()</a> to check if a specific generator has new data.</p>
<p>Once condition is met, OpenNI updates all the generators by calling their <a class="el" href="classxn_1_1_module_generator.html#a543e11766a86916c78d7065d0f4bb4a8">xn::ModuleGenerator::UpdateData()</a> method. The <code>UpdateData()</code> method is the only place where the node implementation is allowed to modify its last updated data.</p>
<dl class="section note"><dt>Note</dt><dd>The generator never calls its <code>UpdateData()</code> method. Only OpenNI calls this method, when the application calls one of the <code>'Wait X Update All'</code> methods.</dd></dl>
<h1><a class="anchor" id="modules_gen_active"></a>
Example A: An Active Generator</h1>
<p>An active generator is a generator that does its generation in a thread other than the application thread.</p>
<p>Usually, its implementation will be as follows:</p>
<ul>
<li>The <a class="el" href="classxn_1_1_module_generator.html#a85a3020712a333d3b36a6af137995b40">StartGenerating()</a> method starts a worker thread or performs an asynchronous call that is responsible for getting new data.</li>
</ul>
<ul>
<li>The <a class="el" href="classxn_1_1_module_generator.html#a58c065a0b750e8680fb294eedddc6a2c">StopGenerating()</a> method stops the worker thread or cancels the asynchronous call.</li>
</ul>
<ul>
<li>The node holds a buffer containing the latest updated data, i.e., the Application Buffer. This is the buffer holding the data the application received after OpenNI most recently called the UpdateData() method (on the application calling WaitXUpdateAll).</li>
</ul>
<ul>
<li>When the worker thread has completed generating the new data (or the asynchronous call has returned), the data is stored in another buffer (the 'next' buffer), and the <em>New Data Available</em> event is raised.</li>
</ul>
<ul>
<li>The <a class="el" href="classxn_1_1_module_generator.html#a15485d6f869ea1a807c256b80cba1873">IsNewDataAvailable()</a> method checks if the 'next' buffer exists.</li>
</ul>
<ul>
<li>The <a class="el" href="classxn_1_1_module_generator.html#a543e11766a86916c78d7065d0f4bb4a8">UpdateData()</a> method changes the 'next' buffer to be the 'user' buffer, and then deletes the previous 'user' buffer.</li>
</ul>
<p>Of course, the explanation above is simplified. Usually, instead of allocating and deleting data buffers, a buffer pool is used, and the implementation should minimize copying data from one buffer to another, in order to reduce consumption of hardware resources.</p>
<h1><a class="anchor" id="modules_gen_passive"></a>
Example B: A Passive Generator</h1>
<p>A passive generator usually depends on the data of another generator. It does some processing in the application thread to produce new data from its input node's data.</p>
<p>Usually, its implementation will be as follows:</p>
<ul>
<li>The <a class="el" href="classxn_1_1_module_generator.html#a85a3020712a333d3b36a6af137995b40">StartGenerating()</a> method registers to the <em>New Data Available</em> event of this node's input nodes, i.e., the previous nodes (feeders) in the production graph.</li>
</ul>
<ul>
<li>The <a class="el" href="classxn_1_1_module_generator.html#a58c065a0b750e8680fb294eedddc6a2c">StopGenerating()</a> method unregisters from this event.</li>
</ul>
<ul>
<li>The node holds a buffer containing the latest updated data, i.e., the Application Buffer. This is the buffer holding the data the application received after OpenNI most recently called the UpdateData() method (on the application calling WaitXUpdateAll).</li>
</ul>
<ul>
<li>When the input nodes' <em>New Data Available</em> event is raised, it raises its own event, also marking that new input data is available for processing (using a member flag).</li>
</ul>
<ul>
<li>The <a class="el" href="classxn_1_1_module_generator.html#a15485d6f869ea1a807c256b80cba1873">IsNewDataAvailable()</a> method checks if this flag is turned on.<dl class="section note"><dt>Note</dt><dd>It is not sufficient to check if the input node has new data available, because this method might be called <b>after</b> the input nodes' UpdateData() method was called, but before your node's UpdateData() method was called. In such a case, the input node will say it has no new data, but its last data wasn't processed yet by your node.</dd></dl>
</li>
<li>The <a class="el" href="classxn_1_1_module_generator.html#a543e11766a86916c78d7065d0f4bb4a8">UpdateData()</a> method takes the input data from the input node, does some processing, updates the "user" buffer, and resets the 'New Data Available' flag. </li>
</ul>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Nov 12 2013 13:40:21 for OpenNI 1.5.7 by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.3.1
</small></address>
</body>
</html>
