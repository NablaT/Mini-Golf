<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>OpenNI 1.5.7: NiUserTracker - sample program</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="OpenNILogo.bmp"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">OpenNI 1.5.7
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="index.html">OpenNI Overview</a></li><li class="navelem"><a class="el" href="smpls_n_guides.html">Samples and Guides</a></li><li class="navelem"><a class="el" href="smpls.html">Sample Programs for the OpenNI API</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">NiUserTracker - sample program </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><pre class="fragment">&lt;b&gt;Source files:&lt;/b&gt; Click the following link to view the source code file:
    - NiUserTracker\main.cpp
    - opengles.cpp
    - SceneDrawer.cpp

This section describes the NiUserTracker sample program written in C++. The executable program for Windows is NiUserTracker.exe.

The documentation describes the sample program's code from the top of the program file to bottom.

Every OpenNI feature is described the first time it appears in this sample program. Further appearances of the same feature are not described again.

FILE NAME: main.cpp
</pre><h1><a class="anchor" id="utcpp_glb_dcl_blk"></a>
Global Declaration Block</h1>
<pre class="fragment">    The following declarations define the OpenNI objects required for building the OpenNI production graph. The production graph is the main object model in OpenNI. 
</pre><div class="fragment"><div class="line"><a class="code" href="classxn_1_1_context.html">xn::Context</a> g_Context;</div>
<div class="line"><a class="code" href="classxn_1_1_script_node.html">xn::ScriptNode</a> g_scriptNode;</div>
<div class="line"><a class="code" href="classxn_1_1_depth_generator.html">xn::DepthGenerator</a> g_DepthGenerator;</div>
<div class="line"><a class="code" href="classxn_1_1_user_generator.html">xn::UserGenerator</a> g_UserGenerator;</div>
<div class="line"><a class="code" href="classxn_1_1_player.html">xn::Player</a> g_Player;</div>
</div><!-- fragment --><p>Each of these concepts is described separately in the following paragraphs.</p>
<p>The <em>production graph</em> is a network of software objects - called production nodes - that can identify blobs as hands or human users. In this sample program the production graph identifies blobs as human users, and tracks them as they move. See <a class="el" href="prod_graph.html">The Production Graph</a> for more about the production graph.</p>
<p>A <a class="el" href="classxn_1_1_context.html">xn::Context</a> object is a workspace in which the application builds an OpenNI production graph.</p>
<p>The <a class="el" href="classxn_1_1_script_node.html">xn::ScriptNode</a> object loads an XML script from a file or string, and then runs the XML script to build a production graph. The ScriptNode object must be kept alive as long as the other nodes are needed.</p>
<p>A <a class="el" href="classxn_1_1_depth_generator.html">xn::DepthGenerator</a> node generates a depth map. Each map pixel value represents a distance from the sensor.</p>
<p>A <a class="el" href="classxn_1_1_user_generator.html">xn::UserGenerator</a> node generates data describing users that it recognizes in the scene, identifying each user individually and thus allowing actions to be done on specific users. The single UserGenerator node gets data for all users appearing in the scene.</p>
<p>A <a class="el" href="classxn_1_1_player.html">xn::Player</a> node plays a saved recording of an OpenNI data generation session.</p>
<h1><a class="anchor" id="utcpp_release"></a>
CleanupExit() function -- Release the Nodes</h1>
<pre class="fragment">    This function releases the OpenNI nodes. Releasing the nodes unreferences them, decreasing their reference counts by 1. If a node's reference count reaches zero, it will be destroyed. In this sample program the result of this function should be the destruction of all the nodes.
    void CleanupExit()
    {
        g_scriptNode.Release();
        g_DepthGenerator.Release();
        g_UserGenerator.Release();
        g_Player.Release();
        g_Context.Release();
        exit (1);
    }
</pre><h1><a class="anchor" id="utcpp_event_handlers"></a>
Declarations of Event Handlers</h1>
<pre class="fragment">    This section describes the event handlers this sample program requires, describing the nature of the events themselves and what is done inside the handlers. 

    A typical order of invocation of the events in the default configuration, where online-calibration is enabled, would be:
    1. 'New User' event
    2. 'Calibration Complete' event
    3. 'Lost User' event

    Online-calibration enables the acquisition of a skeleton without the need for poses.
    The events are described below in order of their declaration in the source code. 

    Note: When online-calibration is turned off ( which is &lt;i&gt;not &lt;/i&gt; the default configuration) a 'Pose Detected' event would typically occur after the 'New User' event and before the Calibration Complete' event.
</pre><h2><a class="anchor" id="utj_newuser_ev_hndlr"></a>
'New User' event handler</h2>
<pre class="fragment">        The &lt;b&gt;'New User' event&lt;/b&gt; signals that a new user has now been recognized in the scene. A new user is a user that was not previously recognized in the scene, and is now recognized in the scene. The user is identified by a persistent ID.

        Below is a typical implementation of the event handler. It's processing is as follows. 
        Now that a new user has been detected, the handler calls @ref xn::PoseDetectionCapability::StartPoseDetection() "StartPoseDetection()" to start pose detection.
</pre> <div class="fragment"><div class="line"><span class="keywordtype">void</span> XN_CALLBACK_TYPE User_NewUser(<a class="code" href="classxn_1_1_user_generator.html">xn::UserGenerator</a>&amp; generator, <a class="code" href="_xn_types_8h.html#a83a03695bbf1ac00ac01d39ad21f01aa">XnUserID</a> nId, <span class="keywordtype">void</span>* pCookie)</div>
<div class="line">{</div>
<div class="line">    XnUInt32 epochTime = 0;</div>
<div class="line">    <a class="code" href="_xn_o_s_8h.html#a8cda4856cd995f10dec4aca69a0ca1a8">xnOSGetEpochTime</a>(&amp;epochTime);</div>
<div class="line">    printf(<span class="stringliteral">&quot;%d New User %d\n&quot;</span>, epochTime, nId);</div>
<div class="line">    <span class="comment">// New user found</span></div>
<div class="line">    <span class="keywordflow">if</span> (g_bNeedPose)</div>
<div class="line">    {</div>
<div class="line">        g_UserGenerator.<a class="code" href="classxn_1_1_user_generator.html#a99ffd208ee85c90dde7c6d9e13b22fd8" title="Gets a xn::PoseDetectionCapability object for accessing Pose Detection functionality.">GetPoseDetectionCap</a>().<a class="code" href="classxn_1_1_pose_detection_capability.html#a8ba21d0b1a6ba12a89fd0100e980121a" title="Starts attempting to detect a pose for a specific user.">StartPoseDetection</a>(g_strPose, nId);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span></div>
<div class="line">    {</div>
<div class="line">        g_UserGenerator.<a class="code" href="classxn_1_1_user_generator.html#abc0af3339edb1f4c623eca7cbaf9221b" title="Gets a SkeletonCapability object for accessing Skeleton functionality.">GetSkeletonCap</a>().<a class="code" href="classxn_1_1_skeleton_capability.html#a3428d28764b594a2816f5aa314188234" title="Starts the calibration process to calibrate a user.">RequestCalibration</a>(nId, <a class="code" href="_xn_platform_8h.html#aa8cecfc5c5c054d2875c03e77b7be15d">TRUE</a>);</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="utcpp_lostuser_ev_hndlr"></a>
'Lost User' event handler</h2>
<pre class="fragment">        The &lt;b&gt;'Lost User' event&lt;/b&gt; signals that a user has been lost from the list of previously recognized users in the scene. The exact meaning of a 'lost user' is decided by the developer of the @ref xn::UserGenerator. However, a typical implementation would define that a lost user is a previously recognized user that then exits the scene and does not return, even after a 'Lost User' timeout has elapsed. Thus this event might be raised only after some delay after the user actually exited the scene.

        Below is a typical implementation of the event handler. It's processing is as follows. 
        Now that an existing user has been lost, the handler deletes the user's entry from the @ref utcs_init_joints_array &lt;code&gt;joints&lt;/code&gt; array.
</pre> <div class="fragment"><div class="line"><span class="keywordtype">void</span> XN_CALLBACK_TYPE User_LostUser(<a class="code" href="classxn_1_1_user_generator.html">xn::UserGenerator</a>&amp; generator, <a class="code" href="_xn_types_8h.html#a83a03695bbf1ac00ac01d39ad21f01aa">XnUserID</a> nId, <span class="keywordtype">void</span>* pCookie)</div>
<div class="line">{</div>
<div class="line">    XnUInt32 epochTime = 0;</div>
<div class="line">    <a class="code" href="_xn_o_s_8h.html#a8cda4856cd995f10dec4aca69a0ca1a8">xnOSGetEpochTime</a>(&amp;epochTime);</div>
<div class="line">    printf(<span class="stringliteral">&quot;%d Lost user %d\n&quot;</span>, epochTime, nId);    </div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="utcpp_posedetect_ev_hndlr"></a>
'Pose Detected' event handler</h2>
<pre class="fragment">        The &lt;b&gt;'Pose Detected' event&lt;/b&gt; signals that a human user made the pose named in the call to the StartPoseDetection() method. The user is designated with the ID given by the &lt;code&gt;nID&lt;/code&gt; parameter.

        Below is a typical implementation of the event handler. It's processing is as follows. 
        Now that a pose has been detected, the handler calls @ref xn::PoseDetectionCapability::StopPoseDetection() "StopPoseDetection()" to stop pose detection. The handler then calls @ref xn::SkeletonCapability::RequestCalibration() "requestSkeletonCalibration()" to start calibration. The &lt;code&gt;true&lt;/code&gt; disregards any previous calibration and forces a new calibration.          
</pre> <div class="fragment"><div class="line"><span class="keywordtype">void</span> XN_CALLBACK_TYPE UserPose_PoseDetected(<a class="code" href="classxn_1_1_pose_detection_capability.html">xn::PoseDetectionCapability</a>&amp; capability, <span class="keyword">const</span> XnChar* strPose, <a class="code" href="_xn_types_8h.html#a83a03695bbf1ac00ac01d39ad21f01aa">XnUserID</a> nId, <span class="keywordtype">void</span>* pCookie)</div>
<div class="line">{</div>
<div class="line">    XnUInt32 epochTime = 0;</div>
<div class="line">    <a class="code" href="_xn_o_s_8h.html#a8cda4856cd995f10dec4aca69a0ca1a8">xnOSGetEpochTime</a>(&amp;epochTime);</div>
<div class="line">    printf(<span class="stringliteral">&quot;%d Pose %s detected for user %d\n&quot;</span>, epochTime, strPose, nId);</div>
<div class="line">    g_UserGenerator.<a class="code" href="classxn_1_1_user_generator.html#a99ffd208ee85c90dde7c6d9e13b22fd8" title="Gets a xn::PoseDetectionCapability object for accessing Pose Detection functionality.">GetPoseDetectionCap</a>().<a class="code" href="classxn_1_1_pose_detection_capability.html#a5ecc3fc3aa1fbd7fbe0a01d3d0c105bc" title="Stops attempting to detect a pose (for a specific user).">StopPoseDetection</a>(nId);</div>
<div class="line">    g_UserGenerator.<a class="code" href="classxn_1_1_user_generator.html#abc0af3339edb1f4c623eca7cbaf9221b" title="Gets a SkeletonCapability object for accessing Skeleton functionality.">GetSkeletonCap</a>().<a class="code" href="classxn_1_1_skeleton_capability.html#a3428d28764b594a2816f5aa314188234" title="Starts the calibration process to calibrate a user.">RequestCalibration</a>(nId, <a class="code" href="_xn_platform_8h.html#aa8cecfc5c5c054d2875c03e77b7be15d">TRUE</a>);</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="utcpp_calibstart_ev_hndlr"></a>
'Calibration Start' event handler</h2>
<pre class="fragment">        The &lt;b&gt;'Calibration Start' event&lt;/b&gt; signals that Signals that a specific user's SkeletonCapability object is now starting the calibration process.

        Below is a typical implementation of the event handler. It has no OpenNI specific code. It just records the time the handler was called and then prints it out.
</pre> <div class="fragment"><div class="line"><span class="keywordtype">void</span> XN_CALLBACK_TYPE UserCalibration_CalibrationStart(<a class="code" href="classxn_1_1_skeleton_capability.html">xn::SkeletonCapability</a>&amp; capability, <a class="code" href="_xn_types_8h.html#a83a03695bbf1ac00ac01d39ad21f01aa">XnUserID</a> nId, <span class="keywordtype">void</span>* pCookie)</div>
<div class="line">{</div>
<div class="line">    XnUInt32 epochTime = 0;</div>
<div class="line">    <a class="code" href="_xn_o_s_8h.html#a8cda4856cd995f10dec4aca69a0ca1a8">xnOSGetEpochTime</a>(&amp;epochTime);</div>
<div class="line">    printf(<span class="stringliteral">&quot;%d Calibration started for user %d\n&quot;</span>, epochTime, nId);</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="utcpp_calibcmplt_ev_hndlr"></a>
'Calibration Complete' event handler</h2>
<pre class="fragment">        The &lt;b&gt;'Calibration Complete' event&lt;/b&gt; signals that a specific user's skeleton has now completed the calibration process, and provides a result status. The user is identified by the ID given by the &lt;code&gt;nId&lt;/code&gt; parameter.

        Below is a typical implementation of the event handler. It's processing is as follows. The handler tests whether the calibration process was completed successfully. If successful, that means that a user has been detected and calibrated, and enough information has been obtained to create a skeleton to represent the user. 

        The handler then advances the processing to the next stage, i.e., to call @ref xn::HandsGenerator::StartTracking() "StartTracking()" to start tracking the skeleton, which represents a human user body, within a real-life (3D) scene for analysis, interpretation, and use by the application.
        (Description continued after the code.)         
</pre> <div class="fragment"><div class="line"><span class="keywordtype">void</span> XN_CALLBACK_TYPE UserCalibration_CalibrationComplete(<a class="code" href="classxn_1_1_skeleton_capability.html">xn::SkeletonCapability</a>&amp; capability, <a class="code" href="_xn_types_8h.html#a83a03695bbf1ac00ac01d39ad21f01aa">XnUserID</a> nId, <a class="code" href="_xn_types_8h.html#ac58d2e4f6ca6abf9d55cdd9377449a77">XnCalibrationStatus</a> eStatus, <span class="keywordtype">void</span>* pCookie)</div>
<div class="line">{</div>
<div class="line">    ...</div>
<div class="line">    <span class="keywordflow">if</span> (eStatus == <a class="code" href="_xn_types_8h.html#ac58d2e4f6ca6abf9d55cdd9377449a77a7e48dedb8aaa2619f73f52647681d9e2">XN_CALIBRATION_STATUS_OK</a>)</div>
<div class="line">    {</div>
<div class="line">        ...</div>
<div class="line">        g_UserGenerator.<a class="code" href="classxn_1_1_user_generator.html#abc0af3339edb1f4c623eca7cbaf9221b" title="Gets a SkeletonCapability object for accessing Skeleton functionality.">GetSkeletonCap</a>().<a class="code" href="classxn_1_1_skeleton_capability.html#a9b6c1de717298ff1540e32c6d2c02260" title="Starts tracking a skeleton.">StartTracking</a>(nId);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span></div>
<div class="line">    {</div>
<div class="line">        printf(<span class="stringliteral">&quot;%d Calibration failed for user %d\n&quot;</span>, epochTime, nId);</div>
<div class="line">        <span class="keywordflow">if</span> (g_bNeedPose)</div>
<div class="line">        {</div>
<div class="line">            g_UserGenerator.<a class="code" href="classxn_1_1_user_generator.html#a99ffd208ee85c90dde7c6d9e13b22fd8" title="Gets a xn::PoseDetectionCapability object for accessing Pose Detection functionality.">GetPoseDetectionCap</a>().<a class="code" href="classxn_1_1_pose_detection_capability.html#a8ba21d0b1a6ba12a89fd0100e980121a" title="Starts attempting to detect a pose for a specific user.">StartPoseDetection</a>(g_strPose, nId);</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span></div>
<div class="line">        {</div>
<div class="line">            g_UserGenerator.<a class="code" href="classxn_1_1_user_generator.html#abc0af3339edb1f4c623eca7cbaf9221b" title="Gets a SkeletonCapability object for accessing Skeleton functionality.">GetSkeletonCap</a>().<a class="code" href="classxn_1_1_skeleton_capability.html#a3428d28764b594a2816f5aa314188234" title="Starts the calibration process to calibrate a user.">RequestCalibration</a>(nId, <a class="code" href="_xn_platform_8h.html#aa8cecfc5c5c054d2875c03e77b7be15d">TRUE</a>);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>In the above handler, if the calibration process failed, the handler restarts the whole calibration sequence. The way the handler restarts the calibration sequence depends on whether the specific generator demands detecting a pose before starting calibration . If a pose is required, the program calls <a class="el" href="classxn_1_1_pose_detection_capability.html#a8ba21d0b1a6ba12a89fd0100e980121a">StartPoseDetection()</a> to start attempting to detect a pose for a specific user.</p>
<p>If a pose is not required, the program calls <a class="el" href="classxn_1_1_user_generator.html#ac41196c59912826bb5eab3ce644cdcfb">GetSkeletonCap()</a>.<a class="el" href="classxn_1_1_skeleton_capability.html#a3428d28764b594a2816f5aa314188234" title="Starts the calibration process to calibrate a user.">xn::SkeletonCapability::RequestCalibration()</a> "RequestCalibration()". <a class="el" href="classxn_1_1_user_generator.html#ac41196c59912826bb5eab3ce644cdcfb">GetSkeletonCap()</a> gets a <a class="el" href="classxn_1_1_skeleton_capability.html">SkeletonCapability</a> object for accessing Skeleton functionality. the <a class="el" href="classxn_1_1_skeleton_capability.html#a3428d28764b594a2816f5aa314188234">RequestCalibration()</a> method starts the calibration process to calibrate a user. The TRUE parameter means to disregard previous calibration to force a further calibration.</p>
<h1><a class="anchor" id="utcpp_sample_xml_path"></a>
Declaration of Path to Sample XML File</h1>
<pre class="fragment">        The following definition is for the path to an OpenNI XML script file. This file is for inputting and building a stored production graph.
</pre> <div class="fragment"><div class="line"><span class="preprocessor">#define SAMPLE_XML_PATH &quot;../../../../Data/SamplesConfig.xml&quot;</span></div>
</div><!-- fragment --><h1><a class="anchor" id="utcpp_fnSaveCalibration"></a>
SaveCalibration() function</h1>
<pre class="fragment">        This routine saves to a file the skeleton calibration data of the first user that it finds is calibrated. .         
        This is a very useful tool for developers. They can save their own calibration, and test their application again without calibrating each time (going into pose, spend time on calibration).            
</pre> <div class="fragment"><div class="line"><span class="preprocessor">#define XN_CALIBRATION_FILE_NAME &quot;UserCalibration.bin&quot;</span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line"><span class="keywordtype">void</span> SaveCalibration()</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="_xn_types_8h.html#a83a03695bbf1ac00ac01d39ad21f01aa">XnUserID</a> aUserIDs[20] = {0};</div>
<div class="line">    XnUInt16 nUsers = 20;</div>
<div class="line">    g_UserGenerator.<a class="code" href="classxn_1_1_user_generator.html#a174c171f0094266c7ee51a0eb1844e86" title="Gets an array of user IDs of all the recognized users in the scene at the current time...">GetUsers</a>(aUserIDs, nUsers);</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; nUsers; ++i)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// Find a user who is already calibrated</span></div>
<div class="line">        <span class="keywordflow">if</span> (g_UserGenerator.<a class="code" href="classxn_1_1_user_generator.html#abc0af3339edb1f4c623eca7cbaf9221b" title="Gets a SkeletonCapability object for accessing Skeleton functionality.">GetSkeletonCap</a>().<a class="code" href="classxn_1_1_skeleton_capability.html#a3d0ac975165ef69497bd50c1127dc806" title="Returns whether a user has been calibrated. see Calibration.">IsCalibrated</a>(aUserIDs[i]))</div>
<div class="line">        {</div>
<div class="line">            <span class="comment">// Save user&#39;s calibration to file</span></div>
<div class="line">            g_UserGenerator.<a class="code" href="classxn_1_1_user_generator.html#abc0af3339edb1f4c623eca7cbaf9221b" title="Gets a SkeletonCapability object for accessing Skeleton functionality.">GetSkeletonCap</a>().<a class="code" href="classxn_1_1_skeleton_capability.html#a318da325962182710b547b7efdf5e912" title="Saves the skeleton&#39;s current calibration data to a file.">SaveCalibrationDataToFile</a>(aUserIDs[i], XN_CALIBRATION_FILE_NAME);</div>
<div class="line">            <span class="keywordflow">break</span>;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}   </div>
</div><!-- fragment --><p>From the code above:</p>
<p>The <code>GetUsers()</code> gets user skeleton calibration data and places it in the <code>aUserIDs</code> array, with one entry per user. Then in the 'save' loop, later on, the code loops through each user in turn testing if it has been calibrated, and when it finds the first calibrated user it saves its calibration data to a file, XN_CALIBRATION_FILE_NAME defined as "UserCalibration.bin" above.</p>
<h1><a class="anchor" id="utcpp_fnLoadCalibration"></a>
LoadCalibration() function</h1>
<pre class="fragment">        The following routine loads the user skeleton calibration data from a file.         
        This is a very useful tool for developers. They can save their own calibration, and test their application again without calibrating each time (going into pose, spend time on calibration). The code loads data only for the first found user that is not yet calibrated or in the middle of being calibrated. 
</pre> <div class="fragment"><div class="line"><span class="keywordtype">void</span> LoadCalibration()</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="_xn_types_8h.html#a83a03695bbf1ac00ac01d39ad21f01aa">XnUserID</a> aUserIDs[20] = {0};</div>
<div class="line">    XnUInt16 nUsers = 20;</div>
<div class="line">    g_UserGenerator.<a class="code" href="classxn_1_1_user_generator.html#a174c171f0094266c7ee51a0eb1844e86" title="Gets an array of user IDs of all the recognized users in the scene at the current time...">GetUsers</a>(aUserIDs, nUsers);</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; nUsers; ++i)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// Find a user who isn&#39;t calibrated or currently in pose</span></div>
<div class="line">        <span class="keywordflow">if</span> (g_UserGenerator.<a class="code" href="classxn_1_1_user_generator.html#abc0af3339edb1f4c623eca7cbaf9221b" title="Gets a SkeletonCapability object for accessing Skeleton functionality.">GetSkeletonCap</a>().<a class="code" href="classxn_1_1_skeleton_capability.html#a3d0ac975165ef69497bd50c1127dc806" title="Returns whether a user has been calibrated. see Calibration.">IsCalibrated</a>(aUserIDs[i])) <span class="keywordflow">continue</span>;</div>
<div class="line">        <span class="keywordflow">if</span> (g_UserGenerator.<a class="code" href="classxn_1_1_user_generator.html#abc0af3339edb1f4c623eca7cbaf9221b" title="Gets a SkeletonCapability object for accessing Skeleton functionality.">GetSkeletonCap</a>().<a class="code" href="classxn_1_1_skeleton_capability.html#aa86d9246c806eacb6fd626290d4cf0e7" title="Returns whether a user is being calibrated right now. see Calibration.">IsCalibrating</a>(aUserIDs[i])) <span class="keywordflow">continue</span>;</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Load user&#39;s calibration from file</span></div>
<div class="line">        <a class="code" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a> rc = g_UserGenerator.<a class="code" href="classxn_1_1_user_generator.html#abc0af3339edb1f4c623eca7cbaf9221b" title="Gets a SkeletonCapability object for accessing Skeleton functionality.">GetSkeletonCap</a>().<a class="code" href="classxn_1_1_skeleton_capability.html#a671f9f5512df03cad3ad57380d9c47ba" title="Loads skeleton calibration data from a file to a skeleton.">LoadCalibrationDataFromFile</a>(aUserIDs[i], XN_CALIBRATION_FILE_NAME);</div>
<div class="line">        <span class="keywordflow">if</span> (rc == <a class="code" href="_xn_status_8h.html#a92729089d8e28e740a3f8b5169c8f695">XN_STATUS_OK</a>)</div>
<div class="line">        {</div>
<div class="line">            <span class="comment">// Make sure state is coherent</span></div>
<div class="line">            g_UserGenerator.<a class="code" href="classxn_1_1_user_generator.html#a99ffd208ee85c90dde7c6d9e13b22fd8" title="Gets a xn::PoseDetectionCapability object for accessing Pose Detection functionality.">GetPoseDetectionCap</a>().<a class="code" href="classxn_1_1_pose_detection_capability.html#a5ecc3fc3aa1fbd7fbe0a01d3d0c105bc" title="Stops attempting to detect a pose (for a specific user).">StopPoseDetection</a>(aUserIDs[i]);</div>
<div class="line">            g_UserGenerator.<a class="code" href="classxn_1_1_user_generator.html#abc0af3339edb1f4c623eca7cbaf9221b" title="Gets a SkeletonCapability object for accessing Skeleton functionality.">GetSkeletonCap</a>().xn::(aUserIDs[i]);</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">break</span>;</div>
<div class="line">    }</div>
<div class="line">}   </div>
</div><!-- fragment --><h1><a class="anchor" id="ytcpp_glut_display"></a>
glutDisplay() method</h1>
<pre class="fragment">    This function is called each frame. There are no OpenNI-specific declarations in this function.
</pre><h1><a class="anchor" id="ytcpp_glut_idle"></a>
glutIdle() method</h1>
<pre class="fragment">    There are no OpenNI-specific declarations in this function.     
</pre><h1><a class="anchor" id="ytcpp_glut_keyboard"></a>
glutKeyboard() method</h1>
<pre class="fragment">    There are no OpenNI-specific declarations in this function.     
</pre><h1><a class="anchor" id="ytcpp_glInit"></a>
glutKeyboard() method</h1>
<pre class="fragment">    There are no OpenNI-specific declarations in this function.             

    The CHECK_RC() macro checks whether the most recent OpenNI operation was successful or returned an error result. On error, the @ref xn::xnGetStatusString "xnGetStatusString()" method converts the OpenNI error return code to the corresponding error string for printing. For the sake of conciseness, the rest of this documentation skips calls to this macro.
</pre> <div class="fragment"><div class="line"><span class="preprocessor">#define CHECK_RC(rc, what) \</span></div>
<div class="line"><span class="preprocessor">  ...</span></div>
</div><!-- fragment --><h1><a class="anchor" id="utcpp_fnglutDisplay"></a>
glutDisplay() function</h1>
<pre class="fragment">    This routine graphically displays the data on a screen. 

    The following declare metadata objects to provide frame objects for the @ref xn::DepthGenerator node and for the @ref xn::UserGenerator node. A @ref dict_gen_node "generator node's" @ref glos_frame_object "frame object" stores a generated data frame and all its associated properties. This data frame and its properties are accessible through the node's metadata object.
</pre> <div class="fragment"><div class="line"><a class="code" href="classxn_1_1_scene_meta_data.html">xn::SceneMetaData</a> sceneMD;</div>
<div class="line"><a class="code" href="classxn_1_1_depth_meta_data.html">xn::DepthMetaData</a> depthMD;</div>
</div><!-- fragment --><p>In the following statements, the <a class="el" href="classxn_1_1_depth_meta_data.html">DepthGenerator frame object</a> is used to access the <a class="el" href="classxn_1_1_map_meta_data.html#a88773e165cbc69e091e87781ca43bdb7">XRes()</a> and <a class="el" href="classxn_1_1_map_meta_data.html#a88773e165cbc69e091e87781ca43bdb7">YRes()</a> methods. These methods return the X and Y dimensions of the depth buffer. These values are used for stepping through the depth map buffer to get the individual pixel values.</p>
<div class="fragment"><div class="line">g_DepthGenerator.<a class="code" href="classxn_1_1_depth_generator.html#a0e05087d3c1652e6f7fa4c002807a22a" title="Gets the depth generator node&#39;s latest frame object, saving it in the xn::DepthMetaData object...">GetMetaData</a>(depthMD);</div>
<div class="line"><span class="preprocessor">#ifndef USE_GLES</span></div>
<div class="line"><span class="preprocessor"></span>    glOrtho(0, depthMD.<a class="code" href="classxn_1_1_map_meta_data.html#a597e11801d9305dfa4c1f78ec249bf0a">XRes</a>(), depthMD.<a class="code" href="classxn_1_1_map_meta_data.html#a4daff8222744af42afbb8114600967f9">YRes</a>(), 0, -1.0, 1.0);</div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line"><span class="preprocessor"></span>    glOrthof(0, depthMD.<a class="code" href="classxn_1_1_map_meta_data.html#a597e11801d9305dfa4c1f78ec249bf0a">XRes</a>(), depthMD.<a class="code" href="classxn_1_1_map_meta_data.html#a4daff8222744af42afbb8114600967f9">YRes</a>(), 0, -1.0, 1.0);</div>
<div class="line"><span class="preprocessor">#endif</span></div>
</div><!-- fragment --><p>the <a class="el" href="classxn_1_1_context.html#ad4bab84f35a855639d485da99a05c585">WaitOneUpdateAll()</a> method in the following statement updates the application buffer of each and every node in the entire production graph, but first waiting for a specified node to have generated a new data frame. The application can then get the new data (for example, using a metadata <code>GetData()</code> method). The WaitOneUpdateAll() method has a timeout. In this sample program, the following statement updates the production graph only if the <a class="el" href="classxn_1_1_user_generator.html">UserGenerator</a> node has new data. </p>
<div class="fragment"><div class="line">g_Context.<a class="code" href="classxn_1_1_context.html#ad4bab84f35a855639d485da99a05c585" title="Updates all generator nodes in the context to their latest available data, first waiting for a specif...">WaitOneUpdateAll</a>(g_UserGenerator);</div>
</div><!-- fragment --><p>The following code block gets the frame objects to use them to draw the depth map, users, and skeletons. Frame objects are a snapshot of the generated map data and its associated configuration information at a certain point in time. Frame objects provide fast and easy access to the DepthGenerator node's data and configuration information.</p>
<div class="fragment"><div class="line">g_DepthGenerator.<a class="code" href="classxn_1_1_depth_generator.html#a0e05087d3c1652e6f7fa4c002807a22a" title="Gets the depth generator node&#39;s latest frame object, saving it in the xn::DepthMetaData object...">GetMetaData</a>(depthMD);</div>
<div class="line">g_UserGenerator.<a class="code" href="classxn_1_1_user_generator.html#aa302a10f2f6f13174a2e2a5bf1746a10" title="Gets the pixel map of the specified user in the scene and saves it in the xn::SceneMetaData object...">GetUserPixels</a>(0, sceneMD);</div>
<div class="line">DrawDepthMap(depthMD, sceneMD);</div>
</div><!-- fragment --><p>In the above, The <a class="el" href="classxn_1_1_depth_generator.html#a0e05087d3c1652e6f7fa4c002807a22a">GetMetaData()</a> gets the DepthGenerator node's <a class="el" href="glossary.html#glos_frame_object">frame object</a>, saving it in the <a class="el" href="classxn_1_1_depth_meta_data.html">xn::DepthMetaData</a> object.</p>
<p><a class="el" href="classxn_1_1_user_generator.html#aa302a10f2f6f13174a2e2a5bf1746a10">GetUserPixels()</a> gets the pixel map of the specified user. This is a pixel map of the entire scene saved as a frame object, where the pixels that represent the body are labeled with user IDs. Each pixel is labeled with the ID of the user that contains that pixel.</p>
<h1><a class="anchor" id="utcpp_func_main"></a>
main() - Main Program</h1>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv)</div>
<div class="line">{</div>
<div class="line">    ...</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="utcpp_init_prod_graph"></a>
Initializing the Production Graph</h2>
<pre class="fragment">        The main program starts by initializing an OpenNI status flag and then initializes the production graph (see the following code). If the program is invoked with a parameter containing a recording name, the program initializes the production graph from the recording file. Otherwise, it initializes the production graph from the standard OpenNI XML file.
</pre> <div class="fragment"><div class="line"><a class="code" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a> nRetVal = <a class="code" href="_xn_status_8h.html#a92729089d8e28e740a3f8b5169c8f695">XN_STATUS_OK</a>;</div>
<div class="line"><span class="keywordflow">if</span> (argc &gt; 1)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// Here the production graph is initialized from a recording </span></div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">else</span></div>
<div class="line">{</div>
<div class="line">  <span class="comment">// Here the production graph is initialized from the standard OpenNI XML file </span></div>
<div class="line">}</div>
</div><!-- fragment --><p><b>Production graph initialized from recording:</b> In the following code block, g_Context.Init() initializes the context. The call to g_Context.xn::Context::OpenFileRecording() "OpenFileRecording()" then opens a recording file. The argv[1] parameter supplies the name of the recording file. The g_Player parameter returns a <a class="el" href="classxn_1_1_player.html">xn::Player</a> node through which playback can be controlled, e.g., seeking and setting playback speed. </p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (argc &gt; 1)</div>
<div class="line">{</div>
<div class="line">    nRetVal = g_Context.<a class="code" href="classxn_1_1_context.html#adfc68c424c840a788d0903e20a95e541" title="Builds the context&#39;s general software environment.">Init</a>();</div>
<div class="line">    CHECK_RC(nRetVal, <span class="stringliteral">&quot;Init&quot;</span>);</div>
<div class="line">    nRetVal = g_Context.<a class="code" href="classxn_1_1_context.html#a3589979f63d5b9ddea49b71dcdf9fc5a" title="Recreates a production graph from a recorded ONI file and then replays the data generation exactly as...">OpenFileRecording</a>(argv[1], g_Player);</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// ... code for testing &amp; printing status - see complete program </span></div>
<div class="line">}</div>
</div><!-- fragment --><p><b>Production graph initialized from standard XML file:</b> In the following code block, g_Context.<a class="el" href="classxn_1_1_context.html#aa0f2dff24c434ed56b44332456ea9502">InitFromXmlFile()</a> initializes the context and loads the script file to build a production graph. SAMPLE_XML_PATH is the path to the XML file, <code>g_scriptNode</code> is the <a class="el" href="classxn_1_1_script_node.html">xn::ScriptNode</a> object as described earlier, and the <code>errors</code> object returns a list of any errors that occurred. </p>
<div class="fragment"><div class="line"><span class="keywordflow">else</span></div>
<div class="line">{</div>
<div class="line">    <a class="code" href="classxn_1_1_enumeration_errors.html">xn::EnumerationErrors</a> errors;</div>
<div class="line">    nRetVal = g_Context.<a class="code" href="classxn_1_1_context.html#aa0f2dff24c434ed56b44332456ea9502" title="Shorthand combination of two other initialization methods - Init() and then RunXmlScriptFromFile() - ...">InitFromXmlFile</a>(SAMPLE_XML_PATH, g_scriptNode, &amp;errors);</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// ... code for testing &amp; printing status - see complete program </span></div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="utcpp_get_nodes_from_prodgrph"></a>
Gets Nodes from Production Graph</h2>
<pre class="fragment">        In the following code, the @ref xn::Context::FindExistingNode() "FindExistingNode()" call gets a reference to production nodes in the production graph. In this example, the application passes the g_depth parameter to get a reference to a @ref xn::DepthGenerator "DepthGenerator node" so that it can work with it. Then the same for a @ref xn::UserGenerator "UserGenerator node".
</pre> <div class="fragment"><div class="line">nRetVal = g_Context.<a class="code" href="classxn_1_1_context.html#a48450b0fde8c947c8ba7683a4f882308" title="Searches for an existing created node of a specified type and returns a reference to it...">FindExistingNode</a>(<a class="code" href="_xn_types_8h.html#ac773bbb9817dac5ae1be0f380ec18b52a1415a428ab99e92cebedd4fdb1fe74c6">XN_NODE_TYPE_DEPTH</a>, g_DepthGenerator);</div>
<div class="line">...</div>
<div class="line">nRetVal = g_Context.<a class="code" href="classxn_1_1_context.html#a48450b0fde8c947c8ba7683a4f882308" title="Searches for an existing created node of a specified type and returns a reference to it...">FindExistingNode</a>(<a class="code" href="_xn_types_8h.html#ac773bbb9817dac5ae1be0f380ec18b52ac93391e720c5a61b844cdee1ebc86ec7">XN_NODE_TYPE_USER</a>, g_UserGenerator);</div>
<div class="line">...</div>
</div><!-- fragment --><h2><a class="anchor" id="utcpp_init_event_hndlrs"></a>
Initialize Event Handlers</h2>
<pre class="fragment">        The following code blocks initialize and register event handlers for the UserGenerator node and its xn::SkeletonCapability "skeleton capability". A skeleton capability provides &lt;b&gt;Skeleton&lt;/b&gt; functionality to a @ref xn::UserGenerator node. First the application checks that the node supports skeleton capability.
</pre> <div class="fragment"><div class="line"><a class="code" href="_xn_types_8h.html#a5d00277c28def4d18f1605d5198ad77d">XnCallbackHandle</a> hUserCallbacks, hCalibrationStart, hCalibrationComplete, hPoseDetected, hCalibrationInProgress, hPoseInProgress;</div>
<div class="line"><span class="keywordflow">if</span> (!g_UserGenerator.<a class="code" href="classxn_1_1_production_node.html#a26574447d96527d1a9d79994e550037f" title="Returns whether a production node supports a specific capability.">IsCapabilitySupported</a>(<a class="code" href="_xn_types_8h.html#a62ac1922557ef6246bec2f2b706b129f">XN_CAPABILITY_SKELETON</a>))</div>
<div class="line">{</div>
<div class="line">    printf(<span class="stringliteral">&quot;Supplied user generator doesn&#39;t support skeleton\n&quot;</span>);</div>
<div class="line">    <span class="keywordflow">return</span> 1;</div>
<div class="line">}               </div>
</div><!-- fragment --><p>To be able to track a user's skeleton, the SkeletonCapability can execute a calibration process to measure and record the lengths of the human user's limbs. This would make it easier for OpenNI to then successfully track the human user. The calibration process can be initiated by the human user performing an agreed calibration pose.</p>
<p>Here is the code for registering the event handlers. The <a class="el" href="classxn_1_1_user_generator.html">xn::UserGenerator</a> accesses its skeleton capability by calling the <a class="el" href="classxn_1_1_user_generator.html#ac41196c59912826bb5eab3ce644cdcfb">xn::UserGenerator::GetSkeletonCap()</a> method. </p>
<div class="fragment"><div class="line">nRetVal = g_UserGenerator.<a class="code" href="classxn_1_1_user_generator.html#a81c4bd31b4dd8dd25e6be52e6e692e50" title="Registers event handlers for the &#39;New User&#39; and &#39;Lost User&#39; events.">RegisterUserCallbacks</a>(User_NewUser, User_LostUser, NULL, hUserCallbacks);</div>
<div class="line">CHECK_RC(nRetVal, <span class="stringliteral">&quot;Register to user callbacks&quot;</span>);</div>
<div class="line">nRetVal = g_UserGenerator.<a class="code" href="classxn_1_1_user_generator.html#abc0af3339edb1f4c623eca7cbaf9221b" title="Gets a SkeletonCapability object for accessing Skeleton functionality.">GetSkeletonCap</a>().<a class="code" href="classxn_1_1_skeleton_capability.html#a1fc75404baca1821cfc13bd1ab5b7a05" title="Registers an event handler for the &#39;Calibration Start&#39; event.">RegisterToCalibrationStart</a>(UserCalibration_CalibrationStart, NULL, hCalibrationStart);</div>
<div class="line">CHECK_RC(nRetVal, <span class="stringliteral">&quot;Register to calibration start&quot;</span>);</div>
<div class="line">nRetVal = g_UserGenerator.<a class="code" href="classxn_1_1_user_generator.html#abc0af3339edb1f4c623eca7cbaf9221b" title="Gets a SkeletonCapability object for accessing Skeleton functionality.">GetSkeletonCap</a>().<a class="code" href="classxn_1_1_skeleton_capability.html#abd1ad65e0775b40d46c1787773c7fbaa" title="Registers an event handler for the &#39;Calibration Complete&#39; event.">RegisterToCalibrationComplete</a>(UserCalibration_CalibrationComplete, NULL, hCalibrationComplete);</div>
<div class="line">CHECK_RC(nRetVal, <span class="stringliteral">&quot;Register to calibration complete&quot;</span>);</div>
</div><!-- fragment --><p>The application then checks if the skeleton capability requires a pose detection in order to execute a calibration. If so, the application will have to get a <a class="el" href="classxn_1_1_pose_detection_capability.html">xn::PoseDetectionCapability</a> object. The code then registers to a 'Pose Detected' event. </p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (g_UserGenerator.<a class="code" href="classxn_1_1_user_generator.html#abc0af3339edb1f4c623eca7cbaf9221b" title="Gets a SkeletonCapability object for accessing Skeleton functionality.">GetSkeletonCap</a>().<a class="code" href="classxn_1_1_skeleton_capability.html#a69ff7c65f2afb5ab2e26f31e90540c17" title="Returns whether a specific pose is required for calibration. This setting is applicable to all users...">NeedPoseForCalibration</a>())</div>
<div class="line">{</div>
<div class="line">    g_bNeedPose = <a class="code" href="_xn_platform_8h.html#aa8cecfc5c5c054d2875c03e77b7be15d">TRUE</a>;</div>
<div class="line">    <span class="keywordflow">if</span> (!g_UserGenerator.<a class="code" href="classxn_1_1_production_node.html#a26574447d96527d1a9d79994e550037f" title="Returns whether a production node supports a specific capability.">IsCapabilitySupported</a>(<a class="code" href="_xn_types_8h.html#abdc214267b28e16ab4e2c15800b03d62">XN_CAPABILITY_POSE_DETECTION</a>))</div>
<div class="line">    {</div>
<div class="line">        printf(<span class="stringliteral">&quot;Pose required, but not supported\n&quot;</span>);</div>
<div class="line">        <span class="keywordflow">return</span> 1;</div>
<div class="line">    }</div>
<div class="line">    nRetVal = g_UserGenerator.<a class="code" href="classxn_1_1_user_generator.html#a99ffd208ee85c90dde7c6d9e13b22fd8" title="Gets a xn::PoseDetectionCapability object for accessing Pose Detection functionality.">GetPoseDetectionCap</a>().<a class="code" href="classxn_1_1_pose_detection_capability.html#a5c6b7593d6e603dfbc1be89629384cd8" title="Registers an event handler for the &#39;Pose Detected&#39; event.">RegisterToPoseDetected</a>(UserPose_PoseDetected, NULL, hPoseDetected);</div>
<div class="line">    CHECK_RC(nRetVal, <span class="stringliteral">&quot;Register to Pose Detected&quot;</span>);</div>
<div class="line">    g_UserGenerator.<a class="code" href="classxn_1_1_user_generator.html#abc0af3339edb1f4c623eca7cbaf9221b" title="Gets a SkeletonCapability object for accessing Skeleton functionality.">GetSkeletonCap</a>().<a class="code" href="classxn_1_1_skeleton_capability.html#a2dd4f975348457837ebdbca87b36f691" title="Gets the name of the pose that is required for calibration. The pose and its name reside in the plug-...">GetCalibrationPose</a>(g_strPose);</div>
<div class="line">}</div>
</div><!-- fragment --><p>The following statement sets the skeleton profile. The skeleton profile specifies which joints are to be active, and which to be inactive. XN_SKEL_PROFILE_ALL means all the joints. The <a class="el" href="classxn_1_1_user_generator.html">xn::UserGenerator</a> node generates output data for the active joints only. This profile applies to all skeletons that the <a class="el" href="classxn_1_1_user_generator.html">xn::UserGenerator</a> node generates. </p>
<div class="fragment"><div class="line">g_UserGenerator.<a class="code" href="classxn_1_1_user_generator.html#abc0af3339edb1f4c623eca7cbaf9221b" title="Gets a SkeletonCapability object for accessing Skeleton functionality.">GetSkeletonCap</a>().<a class="code" href="classxn_1_1_skeleton_capability.html#ab07ee49ccdb7278945af4144bb115c15" title="Sets the skeleton profile. The skeleton profile specifies which joints are to be active, and which to be inactive. The UserGenerator node generates output data for the active joints only. This profile applies to all skeletons that the UserGenerator node generates.">SetSkeletonProfile</a>(<a class="code" href="_xn_types_8h.html#a294999eabe6eeab319a61d3d0093b174a693e6a159f153e47edc3a6b4a1619949">XN_SKEL_PROFILE_ALL</a>);   </div>
</div><!-- fragment --><p>The following statements register to event handlers that report on the progress of detecting a pose and the whole calibration process. </p>
<div class="fragment"><div class="line">nRetVal = g_UserGenerator.<a class="code" href="classxn_1_1_user_generator.html#abc0af3339edb1f4c623eca7cbaf9221b" title="Gets a SkeletonCapability object for accessing Skeleton functionality.">GetSkeletonCap</a>().<a class="code" href="classxn_1_1_skeleton_capability.html#a8181885d362bf59d8d99871e45ed1652" title="Registers an event handler for the &#39;Calibration In Progress&#39; event.">RegisterToCalibrationInProgress</a>(MyCalibrationInProgress, NULL, hCalibrationInProgress);</div>
<div class="line">CHECK_RC(nRetVal, <span class="stringliteral">&quot;Register to calibration in progress&quot;</span>);</div>
<div class="line"></div>
<div class="line">nRetVal = g_UserGenerator.<a class="code" href="classxn_1_1_user_generator.html#a99ffd208ee85c90dde7c6d9e13b22fd8" title="Gets a xn::PoseDetectionCapability object for accessing Pose Detection functionality.">GetPoseDetectionCap</a>().<a class="code" href="classxn_1_1_pose_detection_capability.html#a17e3cdf28e132f66379cb4a99a9b6ffe" title="Registers an event handler for the &#39;Pose In Progress&#39; event.">RegisterToPoseInProgress</a>(MyPoseInProgress, NULL, hPoseInProgress);</div>
<div class="line">CHECK_RC(nRetVal, <span class="stringliteral">&quot;Register to pose in progress&quot;</span>);</div>
</div><!-- fragment --><p>The following statement enters all nodes in the production graph into 'Generating state'. (In this sample application, this includes at least DepthGenerator and UserGenerator.)In this state the node generates new frames. After the application has called this method it calls one of the WaitXUpdateAll methods, e.g., <a class="el" href="classxn_1_1_context.html#a17fab043d7b6d60728511527a1d5c090">WaitAnyUpdateAll()</a>, to update all generator nodes in the context to their latest available data, first waiting for any of the nodes to have new data available. The application can then get the data (for example, using a metadata GetData() method). </p>
<div class="fragment"><div class="line">nRetVal = g_Context.<a class="code" href="classxn_1_1_context.html#affa5173b7c32b98d344ab2c8634f2cb7" title="Ensures all created generator nodes are generating data.">StartGeneratingAll</a>();</div>
<div class="line">CHECK_RC(nRetVal, <span class="stringliteral">&quot;StartGenerating&quot;</span>);</div>
</div><!-- fragment --><p>Here there is a block of statements that are not OpenNI specific.</p>
<p>The following statement destroys all the nodes, releasing their memory. </p>
<div class="fragment"><div class="line">CleanupExit();          </div>
</div><!-- fragment --><p><b>FILE NAME: SceneDrawer.cpp</b></p>
<h1><a class="anchor" id="ut_scenedrawer_cpp_inc"></a>
Includes</h1>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;SceneDrawer.h&quot;</span></div>
<div class="line">...</div>
<div class="line">...</div>
<div class="line"><span class="preprocessor">#include &lt;map&gt;</span></div>
</div><!-- fragment --><h1><a class="anchor" id="ut_evhndlr_calib_in_prgrs"></a>
MyPoseInProgress() - 'Pose in Progress' event handler</h1>
<pre class="fragment">    This event handler - shown below - stores the most recent state of calibration progress, in order to show it as a label later on.
</pre><div class="fragment"><div class="line">std::map&lt;XnUInt32, std::pair&lt;XnCalibrationStatus, XnPoseDetectionStatus&gt; &gt; m_Errors;</div>
<div class="line"><span class="keywordtype">void</span> XN_CALLBACK_TYPE MyCalibrationInProgress(<a class="code" href="classxn_1_1_skeleton_capability.html">xn::SkeletonCapability</a>&amp; capability, <a class="code" href="_xn_types_8h.html#a83a03695bbf1ac00ac01d39ad21f01aa">XnUserID</a> <span class="keywordtype">id</span>, <a class="code" href="_xn_types_8h.html#ac58d2e4f6ca6abf9d55cdd9377449a77">XnCalibrationStatus</a> calibrationError, <span class="keywordtype">void</span>* pCookie)</div>
<div class="line">{</div>
<div class="line">    m_Errors[id].first = calibrationError;</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="ut_evhndlr_calib_in_prgrs"></a>
MyPoseInProgress() - 'Pose in Progress' event handler</h1>
<pre class="fragment">    This event handler - shown below - stores the most recent state of pose progress, in order to show it as a label later on.
</pre> <div class="fragment"><div class="line"><span class="keywordtype">void</span> XN_CALLBACK_TYPE MyPoseInProgress(<a class="code" href="classxn_1_1_pose_detection_capability.html">xn::PoseDetectionCapability</a>&amp; capability, <span class="keyword">const</span> XnChar* strPose, <a class="code" href="_xn_types_8h.html#a83a03695bbf1ac00ac01d39ad21f01aa">XnUserID</a> <span class="keywordtype">id</span>, <a class="code" href="_xn_types_8h.html#a2cbbffcf27ec4330430bbf0b998ae0b8">XnPoseDetectionStatus</a> poseError, <span class="keywordtype">void</span>* pCookie)</div>
<div class="line">{</div>
<div class="line">    m_Errors[id].second = poseError;</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="ut_hist_dec"></a>
Histogram Declarations</h1>
<pre class="fragment">    &lt;code&gt; g_pDepthHist[]&lt;/code&gt; is an array with MAX_DEPTH entries (10,000 at the time of writing), one entry for each depth value that the sensor can output. This array is used for the histogram feature in the &lt;code&gt;DrawDepthMap()&lt;/code&gt; function later in this file.

    Each entry of the array is a counter for the corresponding depth value. 

    &lt;code&gt;Histogram[] &lt;/code&gt; is used in the DrawDepthMap() function later in this file. As the first stage of processing, DrawDepthMap() builds the histogram by scanning the depth map. For each depth pixel, DrawDepthMap() inspects the depth value, and for that value's entry in the array, it increments its counter by 1. The DrawDepthMap() function then performs further processing, as described later in the description for that function.
</pre> <div class="fragment"><div class="line"><span class="preprocessor">#define MAX_DEPTH 10000</span></div>
<div class="line"><span class="preprocessor">float g_pDepthHist[MAX_DEPTH];</span></div>
</div><!-- fragment --><h1><a class="anchor" id="ut_getClosestPowerOfTwo"></a>
getClosestPowerOfTwo() function</h1>
<pre class="fragment">    There are no OpenNI-specific declarations in this routine.
</pre><h1><a class="anchor" id="ut_initTexture"></a>
initTexture() function</h1>
<pre class="fragment">    There are no OpenNI-specific declarations in this routine.          
</pre><h1><a class="anchor" id="ut_DrawRectangle"></a>
DrawRectangle() function</h1>
<pre class="fragment">    There are no OpenNI-specific declarations in this routine.                      
</pre><h1><a class="anchor" id="ut_DrawTexture"></a>
DrawTexture() function</h1>
<pre class="fragment">    There are no OpenNI-specific declarations in this routine.
</pre><h1><a class="anchor" id="ut_glPrintString"></a>
glPrintString() function</h1>
<pre class="fragment">    There are no OpenNI-specific declarations in this routine.
</pre><h1><a class="anchor" id="ut_DrawLimb"></a>
DrawLimb() function</h1>
<pre class="fragment">    This function draws a limb of the avatar representation of a human user by drawing a line between two OpenNI joints, of type @ref xn::XnSkeletonJoint, passed as parameters to this function. The two joints are meaningful points that represent human's body joints.
</pre> <div class="fragment"><div class="line"><span class="keywordtype">void</span> DrawLimb(<a class="code" href="_xn_types_8h.html#a83a03695bbf1ac00ac01d39ad21f01aa">XnUserID</a> player, <a class="code" href="_xn_types_8h.html#ac025301dbcbd9a91e532fa3d8991361d">XnSkeletonJoint</a> eJoint1, <a class="code" href="_xn_types_8h.html#ac025301dbcbd9a91e532fa3d8991361d">XnSkeletonJoint</a> eJoint2)</div>
<div class="line">{</div>
<div class="line">    ...</div>
<div class="line">}</div>
</div><!-- fragment --><p>The human user, <code>player</code>, is specified by an integer <a class="el" href="_xn_types_8h.html#a83a03695bbf1ac00ac01d39ad21f01aa">XnUserID</a> parameter. The two OpenNI joints <a class="el" href="_xn_types_8h.html#a7713dc7b4e1415ffe6c835c5979d65f4">xn::XnSkeletonJoint</a> points are enum indicators, e.g., <a class="el" href="_xn_types_8h.html#ac025301dbcbd9a91e532fa3d8991361da972cc982697178260490313c11fc5768">XN_SKEL_HEAD</a>.</p>
<p>The statements of this function are explained below.</p>
<p>The function verifies that the user is being tracked by calling the <a class="el" href="classxn_1_1_skeleton_capability.html#a3d377a980e3c34cc12fd5354ceda89f2">IsTracking()</a> method. </p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (!g_UserGenerator.<a class="code" href="classxn_1_1_user_generator.html#abc0af3339edb1f4c623eca7cbaf9221b" title="Gets a SkeletonCapability object for accessing Skeleton functionality.">GetSkeletonCap</a>().<a class="code" href="classxn_1_1_skeleton_capability.html#a3d377a980e3c34cc12fd5354ceda89f2" title="Returns whether a user is currently being tracked.">IsTracking</a>(player))</div>
<div class="line">{</div>
<div class="line">    printf(<span class="stringliteral">&quot;not tracked!\n&quot;</span>);</div>
<div class="line">    <span class="keywordflow">return</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><p>The following code block obtains the <a class="el" href="_xn_types_8h.html#a69cf000072ccb570b587429627bc484a">X-Y-Z</a> locations of the two joints. </p>
<div class="fragment"><div class="line"><a class="code" href="_xn_types_8h.html#a69cf000072ccb570b587429627bc484a">xn::XnSkeletonJointPosition</a> joint1, joint2;             g_UserGenerator.<a class="code" href="classxn_1_1_user_generator.html#abc0af3339edb1f4c623eca7cbaf9221b" title="Gets a SkeletonCapability object for accessing Skeleton functionality.">GetSkeletonCap</a>().<a class="code" href="classxn_1_1_skeleton_capability.html#ace0584aa486fc94580003f658a88466c" title="Gets the position of one of the skeleton joints in the most recently generated user data...">GetSkeletonJointPosition</a>(player, eJoint1, joint1);</div>
<div class="line">g_UserGenerator.<a class="code" href="classxn_1_1_user_generator.html#abc0af3339edb1f4c623eca7cbaf9221b" title="Gets a SkeletonCapability object for accessing Skeleton functionality.">GetSkeletonCap</a>().<a class="code" href="classxn_1_1_skeleton_capability.html#ace0584aa486fc94580003f658a88466c" title="Gets the position of one of the skeleton joints in the most recently generated user data...">GetSkeletonJointPosition</a>(player, eJoint2, joint2);</div>
</div><!-- fragment --><p>The following code block draws the avatar's limb by drawing a line between the two adjacent points. It uses the locations <code>joint1 </code> and <code> joint 2</code> obtained above.</p>
<p>The <a class="el" href="_xn_types_8h.html#a69cf000072ccb570b587429627bc484a">xn::XnSkeletonJointPosition</a> coordinates are real-world coordinates, so the <a class="el" href="classxn_1_1_depth_generator.html#a70cda9f296d0ac90088cfafc34e9edd2">convertRealWorldToProjective()</a> is used to convert the real world coordinates to projective coordinates for the purpose of drawing them on a 2D texture. </p>
<div class="fragment"><div class="line"><a class="code" href="struct_xn_vector3_d.html">XnPoint3D</a> pt[2];</div>
<div class="line">pt[0] = joint1.position;</div>
<div class="line">pt[1] = joint2.position;</div>
<div class="line"></div>
<div class="line">g_DepthGenerator.<a class="code" href="classxn_1_1_depth_generator.html#a70cda9f296d0ac90088cfafc34e9edd2" title="Converts a list of points from real world coordinates to projective coordinates.">ConvertRealWorldToProjective</a>(2, pt, pt);           </div>
</div><!-- fragment --><p>The rest of the code in this function draws the line on the graphic display. This code is not OpenNI specific.</p>
<h1><a class="anchor" id="utcpp_get_calibration_error_string"></a>
GetCalibrationErrorString() function</h1>
<pre class="fragment">    This function converts an @ref xn::XnCalibrationStatus type to a string. This is shown in the code block below, with example cases.  
</pre> <div class="fragment"><div class="line"><span class="keyword">const</span> XnChar* GetCalibrationErrorString(<a class="code" href="_xn_types_8h.html#ac58d2e4f6ca6abf9d55cdd9377449a77">XnCalibrationStatus</a> error)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">switch</span> (error)</div>
<div class="line">    {</div>
<div class="line">    <span class="keywordflow">case</span> <a class="code" href="_xn_types_8h.html#ac58d2e4f6ca6abf9d55cdd9377449a77a7e48dedb8aaa2619f73f52647681d9e2">XN_CALIBRATION_STATUS_OK</a>:</div>
<div class="line">        <span class="keywordflow">return</span> <span class="stringliteral">&quot;OK&quot;</span>;</div>
<div class="line">    <span class="keywordflow">case</span> <a class="code" href="_xn_types_8h.html#ac58d2e4f6ca6abf9d55cdd9377449a77a80c995e1913c5cb953134611f4291897">XN_CALIBRATION_STATUS_NO_USER</a>:</div>
<div class="line">        <span class="keywordflow">return</span> <span class="stringliteral">&quot;NoUser&quot;</span>;</div>
<div class="line">    <span class="keywordflow">case</span> <a class="code" href="_xn_types_8h.html#ac58d2e4f6ca6abf9d55cdd9377449a77a9acab7d44f7dd12ebcb1752bb2bcd556">XN_CALIBRATION_STATUS_ARM</a>:</div>
<div class="line">        <span class="keywordflow">return</span> <span class="stringliteral">&quot;Arm&quot;</span>;</div>
<div class="line">    <span class="keywordflow">case</span> <a class="code" href="_xn_types_8h.html#ac58d2e4f6ca6abf9d55cdd9377449a77a108750d9d46dd22ea11bdbc036cc9aa7">XN_CALIBRATION_STATUS_LEG</a>:</div>
<div class="line">        <span class="keywordflow">return</span> <span class="stringliteral">&quot;Leg&quot;</span>;       </div>
<div class="line">        </div>
<div class="line">    ...</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="utcpp_get_pose_error_string"></a>
GetPoseErrorString() function</h1>
<pre class="fragment">    This function converts an @ref xn::XnPoseDetectionStatus type to a string. This is shown in the code block below, with example cases.  
</pre> <div class="fragment"><div class="line"><span class="keyword">const</span> XnChar* GetPoseErrorString(<a class="code" href="_xn_types_8h.html#a2cbbffcf27ec4330430bbf0b998ae0b8">XnPoseDetectionStatus</a> error)</div>
<div class="line">{       </div>
<div class="line">    <span class="keywordflow">switch</span> (error)</div>
<div class="line">    {</div>
<div class="line">    <span class="keywordflow">case</span> <a class="code" href="_xn_types_8h.html#a2cbbffcf27ec4330430bbf0b998ae0b8a13c583ef430111dc83bb493f7e4fb850">XN_POSE_DETECTION_STATUS_OK</a>:</div>
<div class="line">        <span class="keywordflow">return</span> <span class="stringliteral">&quot;OK&quot;</span>;</div>
<div class="line">    <span class="keywordflow">case</span> <a class="code" href="_xn_types_8h.html#a2cbbffcf27ec4330430bbf0b998ae0b8af5df3e36670e51abb1f337745a12452d">XN_POSE_DETECTION_STATUS_NO_USER</a>:</div>
<div class="line">        <span class="keywordflow">return</span> <span class="stringliteral">&quot;NoUser&quot;</span>;</div>
<div class="line">    <span class="keywordflow">case</span> <a class="code" href="_xn_types_8h.html#a2cbbffcf27ec4330430bbf0b998ae0b8a7d94841658e606d6cab13673778be771">XN_POSE_DETECTION_STATUS_TOP_FOV</a>:</div>
<div class="line">        <span class="keywordflow">return</span> <span class="stringliteral">&quot;Top FOV&quot;</span>;       </div>
<div class="line">    ...</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="utcpp_fndrawdepthmap"></a>
DrawDepthMap() function</h1>
<pre class="fragment">    The DrawDepthMap() function is located on the &lt;code&gt;SceneDrawer.cpp&lt;/code&gt; file. In this function, both the frame objects -- &lt;code&gt;dmd&lt;/code&gt; and &lt;code&gt;smd&lt;/code&gt; -- are accessed to get their data. The same method is used, &lt;code&gt;Data()&lt;/code&gt;, which is the standard metadata method for returning a pointer to a frame object's data. 
</pre> <div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="_xn_types_8h.html#ad55e431b82556504d5c1c00d153156c9">XnDepthPixel</a>* pDepth = dmd.<a class="code" href="classxn_1_1_depth_meta_data.html#a31c9bda08462e89c9962268f3bf194fe" title="Returns the depth map.">Data</a>();</div>
<div class="line"><span class="keyword">const</span> <a class="code" href="_xn_types_8h.html#aec5b09539e1c361fc5d6bc534447a610">XnLabel</a>* pLabels = smd.Data();            </div>
</div><!-- fragment --><p>The main user processing loop of this function gets each user in turn and displays it. The following declarations support this processing:</p>
<h2><a class="anchor" id="utcpp_ddm_calc_hist"></a>
Calculate the Accumulative Histogram</h2>
<pre class="fragment">        The following initializations are for calculating the accumulative histogram.

        The following statement accesses the Map Output mode to get the DepthGenerator's map dimensions and pixel color format. @ref xn::DepthMap::XRes "XRes" and @ref xn::DepthMap::YRes "YRes" get the frame X an Y resolutions of the most recently generated data. X and is the number of columns and rows, respectively, in the frame after any required cropping has been applied. See @ref conc_map_wrapper_classes "Map Wrapper Classes" for more information.&lt;br&gt;
</pre> <div class="fragment"><div class="line">XnUInt16 g_nXRes = dmd.<a class="code" href="classxn_1_1_map_meta_data.html#a597e11801d9305dfa4c1f78ec249bf0a">XRes</a>();</div>
<div class="line">XnUInt16 g_nYRes = dmd.<a class="code" href="classxn_1_1_map_meta_data.html#a4daff8222744af42afbb8114600967f9">YRes</a>();</div>
</div><!-- fragment --><p>The following code block calculates the accumulative histogram.</p>
<p>The following statement initializes the histogram array. This array is a key part of this sample program. (This code is not OpenNI specific.) The histogram feature of this sample program creates a gradient of the scene's depth scene, from dark (far away) to light (close), regardless of the color.</p>
<p>The first loop, a nested for- loop just counts the frequency of each depth value. </p>
<div class="fragment"><div class="line">memset(g_pDepthHist, 0, MAX_DEPTH*<span class="keyword">sizeof</span>(<span class="keywordtype">float</span>));</div>
<div class="line"><span class="keywordflow">for</span> (nY=0; nY&lt;g_nYRes; nY++)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">for</span> (nX=0; nX&lt;g_nXRes; nX++)</div>
<div class="line">    {</div>
<div class="line">        nValue = *pDepth;</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (nValue != 0)</div>
<div class="line">        {</div>
<div class="line">            g_pDepthHist[nValue]++;</div>
<div class="line">            nNumberOfPoints++;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        pDepth++;</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>The following loop converts the frequency count into an accumulative count. Starting from the first entry this loop calculates a new value for each entry's counter as the sum of itself (<code>[n]</code>) and the value of the previous counter (<code>[n-1]</code>). </p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (nIndex=1; nIndex&lt;MAX_DEPTH; nIndex++)</div>
<div class="line">{</div>
<div class="line">    g_pDepthHist[nIndex] += g_pDepthHist[nIndex-1];</div>
<div class="line">}       </div>
</div><!-- fragment --><p>The following code block completes the histogram. </p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (nNumberOfPoints)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">for</span> (nIndex=1; nIndex&lt;MAX_DEPTH; nIndex++)</div>
<div class="line">    {</div>
<div class="line">        g_pDepthHist[nIndex] = (<span class="keywordtype">unsigned</span> int)(256 * (1.0f - (g_pDepthHist[nIndex] / nNumberOfPoints)));</div>
<div class="line">    }</div>
<div class="line">}       </div>
</div><!-- fragment --><h2><a class="anchor" id="utcpp_ddm_set_color"></a>
Sets Color according to User</h2>
<pre class="fragment">            This code block loops over all the depth values, checking to which user each pixel belongs, and sets the color in the texture according to the user (white for background, others for specific users) and the distance (hue).
</pre> <div class="fragment"><div class="line">pDepth = dmd.<a class="code" href="classxn_1_1_depth_meta_data.html#a31c9bda08462e89c9962268f3bf194fe" title="Returns the depth map.">Data</a>();</div>
<div class="line"><span class="keywordflow">if</span> (g_bDrawPixels)</div>
<div class="line">{</div>
<div class="line">    XnUInt32 nIndex = 0;</div>
<div class="line">    <span class="comment">// Prepare the texture map</span></div>
<div class="line">    <span class="keywordflow">for</span> (nY=0; nY&lt;g_nYRes; nY++)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">for</span> (nX=0; nX &lt; g_nXRes; nX++, nIndex++)</div>
<div class="line">        {</div>
<div class="line"></div>
<div class="line">            pDestImage[0] = 0;</div>
<div class="line">            pDestImage[1] = 0;</div>
<div class="line">            pDestImage[2] = 0;</div>
<div class="line">            <span class="keywordflow">if</span> (g_bDrawBackground || *pLabels != 0)</div>
<div class="line">            {</div>
<div class="line">                nValue = *pDepth;</div>
<div class="line">                <a class="code" href="_xn_types_8h.html#aec5b09539e1c361fc5d6bc534447a610">XnLabel</a> label = *pLabels;</div>
<div class="line">                XnUInt32 nColorID = label % nColors;</div>
<div class="line">                <span class="keywordflow">if</span> (label == 0)</div>
<div class="line">                {</div>
<div class="line">                    nColorID = nColors;</div>
<div class="line">                }</div>
<div class="line"></div>
<div class="line">                <span class="keywordflow">if</span> (nValue != 0)</div>
<div class="line">                {</div>
<div class="line">                    nHistValue = g_pDepthHist[nValue];</div>
<div class="line"></div>
<div class="line">                    pDestImage[0] = nHistValue * Colors[nColorID][0]; </div>
<div class="line">                    pDestImage[1] = nHistValue * Colors[nColorID][1];</div>
<div class="line">                    pDestImage[2] = nHistValue * Colors[nColorID][2];</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            pDepth++;</div>
<div class="line">            pLabels++;</div>
<div class="line">            pDestImage+=3;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        pDestImage += (texWidth - g_nXRes) *3;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">else</span></div>
<div class="line">{</div>
<div class="line">    <a class="code" href="_xn_o_s_memory_8h.html#ad0f2ea99cefaa47ac9750f8c434097de">xnOSMemSet</a>(pDepthTexBuf, 0, 3*2*g_nXRes*g_nYRes);</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="utcpp_ddm_loop"></a>
Main Loop for Processing Users (DrawDepthMap())</h2>
<pre class="fragment">            The main loop of this function for processing users gets each user in turn and displays it.  
</pre> <div class="fragment"><div class="line"><span class="keywordtype">char</span> strLabel[50] = <span class="stringliteral">&quot;&quot;</span>;</div>
<div class="line"><a class="code" href="_xn_types_8h.html#a83a03695bbf1ac00ac01d39ad21f01aa">XnUserID</a> aUsers[15];</div>
<div class="line">XnUInt16 nUsers = 15;</div>
<div class="line">g_UserGenerator.<a class="code" href="classxn_1_1_user_generator.html#a174c171f0094266c7ee51a0eb1844e86" title="Gets an array of user IDs of all the recognized users in the scene at the current time...">GetUsers</a>(aUsers, nUsers);</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; nUsers; ++i)</div>
<div class="line">    ...</div>
<div class="line">    ...</div>
<div class="line">    ...</div>
<div class="line">}</div>
</div><!-- fragment --><p>The following code block gets a user's center of mass (CoM). This is a single point for representing the user. The CoM is a useful point to represent the user. When you don't have any other reference point (e.g., you don't have the position of a specific joint, or of the head, or any other such point), this is an adequate point with which to start to represent the user. This application uses the CoM as the position at which it writes the user's label. The label comprises its user ID and its current state.</p>
<div class="fragment"><div class="line"><a class="code" href="struct_xn_vector3_d.html">XnPoint3D</a> com;</div>
<div class="line">g_UserGenerator.<a class="code" href="classxn_1_1_user_generator.html#a451c8a197374b567e62622f5edcb1670" title="Gets the position of a user&#39;s center of mass. This is the single point for representing the user...">GetCoM</a>(aUsers[i], com);</div>
<div class="line">g_DepthGenerator.<a class="code" href="classxn_1_1_depth_generator.html#a70cda9f296d0ac90088cfafc34e9edd2" title="Converts a list of points from real world coordinates to projective coordinates.">ConvertRealWorldToProjective</a>(1, &amp;com, &amp;com);</div>
</div><!-- fragment --><p>The following statements access the status of each user to display it above each corresponding user image that is displayed on the output display device.</p>
<p>The following statement adds the user's ID to the label, to be displayed on the com of the user the name of the user. </p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (!g_bPrintState)</div>
<div class="line">    sprintf(strLabel, <span class="stringliteral">&quot;%d&quot;</span>, aUsers[i]);</div>
</div><!-- fragment --><p>The following statement gets whether the user's skeleton is being tracked. </p>
<div class="fragment"><div class="line"><span class="keywordflow">else</span> <span class="keywordflow">if</span> (g_UserGenerator.<a class="code" href="classxn_1_1_user_generator.html#abc0af3339edb1f4c623eca7cbaf9221b" title="Gets a SkeletonCapability object for accessing Skeleton functionality.">GetSkeletonCap</a>().<a class="code" href="classxn_1_1_skeleton_capability.html#a3d377a980e3c34cc12fd5354ceda89f2" title="Returns whether a user is currently being tracked.">IsTracking</a>(aUsers[i]))</div>
<div class="line">    sprintf(strLabel, <span class="stringliteral">&quot;%d - Tracking&quot;</span>, aUsers[i]);</div>
</div><!-- fragment --><p>The following statement gets whether the user's skeleton is still in the middle of being being calibrated. This means that tracking has not yet started. </p>
<div class="fragment"><div class="line"><span class="keywordflow">else</span> <span class="keywordflow">if</span> (g_UserGenerator.<a class="code" href="classxn_1_1_user_generator.html#abc0af3339edb1f4c623eca7cbaf9221b" title="Gets a SkeletonCapability object for accessing Skeleton functionality.">GetSkeletonCap</a>().<a class="code" href="classxn_1_1_skeleton_capability.html#aa86d9246c806eacb6fd626290d4cf0e7" title="Returns whether a user is being calibrated right now. see Calibration.">IsCalibrating</a>(aUsers[i]))</div>
<div class="line">    sprintf(strLabel, <span class="stringliteral">&quot;%d - Calibrating [%s]&quot;</span>, aUsers[i], GetCalibrationErrorString(m_Errors[aUsers[i]].first));</div>
</div><!-- fragment --><p>The following 'else-other' statement displays that the application is still looking for the user to start a pose in order to start calibration and the current status of the pose detection. Values are: OK, NO_USER, TOP_FOV, SIDE_FOV, ERROR </p>
<div class="fragment"><div class="line"><span class="keywordflow">else</span> {</div>
<div class="line">    sprintf(strLabel, <span class="stringliteral">&quot;%d - Looking for pose [%s]&quot;</span>, aUsers[i], GetPoseErrorString(m_Errors[aUsers[i]].second)); }</div>
</div><!-- fragment --><p>Finally, this application demonstrates an example method, <code>DrawLimb()</code> , for drawing limbs of all tracked users on a graphical display. A limb is the graphical representation of the human user's arm or leg for example. This method works by taking two parameters that specify a start joint and an end joint for drawing a vector that represents the limb. For example, a 'head' start joint to a 'neck' end joint draws the neck; 'neck' to 'left shoulder' draws the 'left shoulder bridge'.</p>
<p>The call looks something like this: </p>
<div class="fragment"><div class="line">DrawLimb(aUsers[i], <a class="code" href="_xn_types_8h.html#ac025301dbcbd9a91e532fa3d8991361da972cc982697178260490313c11fc5768">XN_SKEL_HEAD</a>, <a class="code" href="_xn_types_8h.html#ac025301dbcbd9a91e532fa3d8991361dabb6c3dc5032aacc6d6c4983d5d510f7d">XN_SKEL_NECK</a>);</div>
</div><!-- fragment --> </div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Nov 12 2013 13:40:21 for OpenNI 1.5.7 by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.3.1
</small></address>
</body>
</html>
