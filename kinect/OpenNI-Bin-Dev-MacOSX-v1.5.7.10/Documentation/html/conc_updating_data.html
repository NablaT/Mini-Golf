<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>OpenNI 1.5.7: Making Data Available using the WaitXUpdateAll() Methods</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="OpenNILogo.bmp"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">OpenNI 1.5.7
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="index.html">OpenNI Overview</a></li><li class="navelem"><a class="el" href="concepts.html">Concepts</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Making Data Available using the WaitXUpdateAll() Methods </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Generator nodes can be generating new data all the time. Meanwhile, however, an application typically needs to be using one consistent data set (data frame and associated data) all received at any one time, until it has completed processing the frame. For this reason, an OpenNI generator holds its new data internally only, until the application explicitly asks the generator to update its data to the new data. This request is done by an 'Update Data' command. OpenNI API provides the <a class="el" href="classxn_1_1_generator.html#aaf3162a87a79a05fa655f344c835fa2e">xn::Generator::WaitAndUpdateData()</a> method to let the application wait for the generator to have generated new data. This method causes it to be 'updated', which means that it copies it to the node's application buffer.</p>
<p>In some cases, the production graph comprises of more than one node, and the application will usually want all the nodes to be updated at once. OpenNI supplies a family of methods &ndash; called the <code>WaitXUpdateAll()</code> methods &ndash; to update the nodes all at once, depending on which approach the application wants to use to update the nodes. For a summary of the <b>WaitXUpdateAll</b> methods, see <a class="el" href="conc_updating_data.html#conc_updating_data__summary_of_wait_fns">'Wait and Update' Methods</a> below.</p>
<p>Unless needing to update only a specific node, it is highly advised to use one of the '<code>Update All</code>' functions. In addition, for updating all the nodes these '<code>Update All</code>' functions have some further benefits:</p>
<ul>
<li>If nodes are dependent on each other, it promises that the needed node will be updated before the needing node.</li>
</ul>
<ul>
<li>If playing a recording, it reads data from the recording until the condition is met.</li>
</ul>
<ul>
<li>If a recorder exists, it records the data from all nodes added to it (without the need to call <a class="el" href="classxn_1_1_recorder.html#a94a2c702fd2c5e2466b813bb585e6fc9">xn::Recorder::Record()</a>).</li>
</ul>
<h1><a class="anchor" id="conc_updating_data__summary_of_wait_fns"></a>
'Wait and Update' Methods</h1>
<pre class="fragment">The 'WaitXandUpdateAll' methods are a family of methods of the @ref 
xn::Context "Context" class that act on the entire production graph, 
i.e., they act on each and every one of the generator nodes in the 
context. Calling a 'WaitXandUpdateAll' method 'updates' the nodes, that 
is, the method ensures that the accessible data from each and every node 
is the node's most recently generated data. 

Each of the 'WaitXandUpdateAll' methods performs a different type of 
'wait' prior to performing the 'update' &amp;ndash; see below for separate 
descriptions of each of these methods. 

- @ref xnWaitAndUpdateAll() (@ref xn::Context::WaitAndUpdateAll()) - 
  Updates all generator nodes in the context, first waiting for each node 
  to have new data available. 

- @ref xnWaitAnyUpdateAll() (@ref xn::Context::WaitAnyUpdateAll()) - 
  Waits for any node to have new data. Once new data is available from any 
  node, all nodes are updated. 

- @ref xnWaitOneUpdateAll() (@ref xn::Context::WaitOneUpdateAll()) - 
  Waits for a specific node to have new data. Once new data is available 
  from this node, all nodes are updated. This is especially useful when 
  having several nodes producing data, but only one determines the 
  progress of the application. 

- @ref xnWaitNoneUpdateAll() (@ref xn::Context::WaitNoneUpdateAll()) - 
  Does not wait for anything. All nodes are updated. 

There is also a WaitAndUpdateData() method that is a member of a 
specific node. This is a member of the @ref xn::Generator class. The 
difference between them is that the 'WaitXAndUpdateData' methods update 
the application buffers of all the nodes in the entire context all at 
once, specifying which type of wait to perform first. In contrast, the 
@ref xn::Generator::WaitAndUpdateData() method waits only on the 
specified node and then updates its application buffer. 
</pre><h1><a class="anchor" id="conc_updating_data__in_depth"></a>
In Depth</h1>
<pre class="fragment">It is understood from the above that even when nodes are generating 
data, the application cannot get any of their new data until it calls 
one of these 'wait and update' methods. Typically, a call to one of 
these methods will be placed in the main program loop. 

Note that these methods are not one-off calls for setting a mode for 
all future updates. As already mentioned, one of these methods must be 
called each time the application wishes to cause new generated data to 
be output. 

These methods exit after a timeout of two seconds. 

The nodes output their next new generated data items in their order of 
dependencies, i.e., these methods guarantee that the 'server' node (the 
lower-level node generating the data for another node) is updated before 
the 'client' node. 

When @ref xn::Player "Player" playing data from a recording, depending 
on the mode, these methods read data from the recreated nodes exactly as 
for live nodes. 

If a recorder exists, these methods automatically record the data from 
all nodes added to this recorder. 
</pre><h1><a class="anchor" id="conc_updating_data__sample_code_cmn"></a>
Sample Code</h1>
<pre class="fragment">Here is an example of updating data and getting data. This particular 
example uses a node with an associated @ref glos_frame_object "frame 
object". The frame object is contained in a @ref conc_meta_data 
"metadata" object. 

After calling an 'Update Data' method (in this example, the node's @ref 
xn::Generator::WaitAndUpdateData() "WaitAndUpdateData()" method), the 
application must call the node's &lt;code&gt;GetMetaData()&lt;/code&gt; method to 
get the node's latest generated frame object and save it as metadata. 

The node's &lt;code&gt;GetMetaData()&lt;/code&gt; method gets the node's frame 
object that is. An example of a metadata object is @ref 
xn::DepthMetaData, which is the metadata object for a @ref 
xn::DepthGenerator "DepthGenerator" node. 

&lt;b&gt;Code example: &lt;/b&gt;
</pre><div class="fragment"><div class="line">DepthGenerator depth;</div>
<div class="line">depth.StartGenerating();</div>
<div class="line"></div>
<div class="line">DepthMetaData depthMD;</div>
<div class="line"><span class="keywordflow">while</span> forever</div>
<div class="line">{ </div>
<div class="line">    depth.WaitAndUpdateData();  </div>
<div class="line">    depth.GetMetaData(depthMD); </div>
<div class="line">    </div>
<div class="line">    XnUInt32 xRes = depthMD.XRes();</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="_xn_types_8h.html#ad55e431b82556504d5c1c00d153156c9">XnDepthPixel</a>* pDepthMap = depthMD.Data();</div>
<div class="line">}</div>
</div><!-- fragment --><p>Note that for each 'Update Data' call (e.g., <a class="el" href="classxn_1_1_generator.html#aaf3162a87a79a05fa655f344c835fa2e">xn::Generator::WaitAndUpdateData()</a> above) the application must then again get the new data (using the node's <code>GetMetaData()</code> method). This is true also when accessing the data through metadata. That is, the metadata is not permanently attached to the node's new output.</p>
<p>In some cases, the production graph comprises of more than one node, and the application will usually want all the nodes to be updated at once. OpenNI supplies a family of methods &amp;nbsp called the <code>WaitXUpdateAll()</code> methods &amp;nbsp to update the nodes all at once. For more information on the <code>WaitXUpdateAll()</code> methods see <a class="el" href="conc_updating_data.html">Making Data Available using the WaitXUpdateAll() Methods</a>. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Nov 12 2013 13:40:21 for OpenNI 1.5.7 by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.3.1
</small></address>
</body>
</html>
