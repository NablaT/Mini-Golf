<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>OpenNI 1.5.7: The Production Graph</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="OpenNILogo.bmp"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">OpenNI 1.5.7
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="index.html">OpenNI Overview</a></li><li class="navelem"><a class="el" href="concepts.html">Concepts</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">The Production Graph </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The <em>production graph</em> is a network of <em>production nodes</em>. This is the principal OpenNI object model. The fundamental purpose and functionality of the production graph is to identify and track <em>blobs</em> as human hands or users.</p>
<p>A production graph is composed of a production node, and optionally a list of other production nodes needed for this production node. Each production node has a type (one of the types defined by the OpenNI specification), a vendor name, and a specific name (unique for this type and vendor), and a version. For example, a <a class="el" href="classxn_1_1_user_generator.html">UserGenerator</a> node may need a <a class="el" href="classxn_1_1_depth_generator.html">DepthGenerator</a> node, which in turn might need a <a class="el" href="classxn_1_1_device.html">Device </a> node.</p>
<h1><a class="anchor" id="enum_reg_mdls"></a>
Enumerating the Registered Modules</h1>
<pre class="fragment">When OpenNI is initializing, it loads each registered module, and asks 
it for the types of nodes it implements. Then, when an application asks 
for a specific generated product, OpenNI enumerates every module that 
declared itself as generating that product, for currently possible 
production graphs. Each module builds a list of nodes it can create 
right now (possible by enumerating for other node types), and returns it 
to OpenNI. OpenNI then appends all those lists together, and returns 
them to the application. The application can then choose the specific 
node it wants to use right now, and asks OpenNI to create it. 
</pre><h1><a class="anchor" id="crt_prd_nds"></a>
Creating Production Nodes</h1>
<pre class="fragment">There are several ways to create production nodes:

- Using the @ref xn::Context::EnumerateProductionTrees() 
  "EnumerateProductionTrees()" method &amp;ndash; choosing one result and 
  calling CreateProductionTree() with this result 
- Using the @ref xn::Context::CreateAnyProductionTree() 
  "CreateAnyProductionTree()" method &amp;ndash; shorthand for enumerating and 
  choosing any result 
- Using XML files       
</pre><h1><a class="anchor" id="enum_to_crt_prd_nds"></a>
Enumerating to Create Production Nodes</h1>
<pre class="fragment">The result from an enumeration operation is a pointer to the first node 
of a linked list, representing all the matching @ref node_alternative 
"node alternatives". Each @ref node_alternative "node alternative" 
contains the provider description, an optional instance name (that can 
be used by the provider as proprietary information, like a device S/N), 
and a list of the node's dependencies (other needed nodes). 
</pre><h1><a class="anchor" id="enuming_with_constraints"></a>
Enumerating with Constraints</h1>
<pre class="fragment">When an application wants to create a production node, in most cases it 
will prefer (or even demand) certain constraints from those nodes. For 
example, an application might need the node to support a specific 
capability it needs. For this reason, the enumeration functions can take 
a @ref xn::Query "Query" object as a parameter (see @ref queries for C, 
or @ref xn::Query for C++). 
</pre><dl class="section note"><dt>Note</dt><dd>OpenNI can also return existing nodes during enumeration, if they match the requested criterias.</dd></dl>
<h1><a class="anchor" id="enuming_for_type"></a>
Enumerating only for a Particular Type</h1>
<pre class="fragment">As a shortcut, in case the application doesn't care about different 
nodes, and just needs any node of the requested type, it can do so using 
one of the following functions: 

- @ref xnCreateDepthGenerator()
- @ref xnCreateImageGenerator()
- @ref xnCreateIRGenerator()
- @ref xnCreateAudioGenerator()
- @ref xnCreateGestureGenerator()
- @ref xnCreateSceneAnalyzer()
- @ref xnCreateHandsGenerator()
- @ref xnCreateUserGenerator()

In C++ this can be done using

- @ref xn::DepthGenerator::Create()
- @ref xn::ImageGenerator::Create()
- @ref xn::IRGenerator::Create()
- @ref xn::AudioGenerator::Create()
- @ref xn::GestureGenerator::Create()
- @ref xn::SceneAnalyzer::Create()
- @ref xn::HandsGenerator::Create()
- @ref xn::UserGenerator::Create()

Note that just like in the full enumeration process, these functions 
also allow the application to specify certain constraints about the 
created nodes with a @ref xn::Query "Query" object, such as the vendor 
that supplies the generator, a version number, certain capabilities, and 
more (see @ref queries for the C functions, or @ref xn::Query for the 
C++ functions). 
</pre><h1><a class="anchor" id="nod_hndls"></a>
Node Handles</h1>
<pre class="fragment">In the C interface, each production node in the context is accessed 
using a @ref XnNodeHandle "node handle". 

Every function on a specific node takes the node handle as its first 
argument. In C++, every class inheriting from @ref xn::NodeWrapper holds 
the handle as a member, making it easier for applications to use the 
methods. 
</pre><h1><a class="anchor" id="bld_prod_graph"></a>
Building the Production Graph</h1>
<pre class="fragment">An application usually needs just one 3D vision product to be generated 
by OpenNI (human pose, gestures recognition, etc.). However this 
generated product is usually produced using a production graph. This 
means the vision product can be generated in a number of ways - either 
by different algorithms or the same algorithm using different raw data 
for processing. 

When an application asks OpenNI for a specific generated product, OpenNI 
returns a list of all currently possible ways of producing it. This 
depends on installed modules, currently attached devices, and available 
licenses. 

A production graph is represented using an object called Node Info (see 
@ref prdnodeinfo for C, or @ref xn::NodeInfo for C++). This object 
contains information about the current node, such as its vendor, name, 
version, and most importantly, its type. The node info object can 
represent either an existing node that was already created, or an option 
for creating a node. For example, if an application enumerates for a 
node in the first time with @ref xnEnumerateProductionTrees, it will 
probably get a node info object which is not connected to an existing 
node. Once the application chooses to create this node with @ref 
xnCreateProductionTree, a node will be created, and the node info object 
will also hold the node handle. 

The application can choose a production graph according to some or all 
nodes in the graph. For example, suppose an application asks for a User 
Generator. A User Generator requires a Depth Generator to operate, and 
suppose there are two types of Depth Generators installed on the 
machine. In this case the application would get two production chains 
for the User Generator: One for each option of the underlying Depth 
Generator. The application can then choose the preferred production 
graph according to its considerations, e.g. choosing a specific vendor, 
or choosing a depth node that provides certain capabilities. 

Each Node Info object holds a list of needed nodes, thus creating a 
nodes graph. The list of needed nodes is accessed using an object called 
Node Info List (see @ref infolist for C, or @ref xn::NodeInfoList for 
C++). 
</pre><h2><a class="anchor" id="create_method"></a>
Understanding the Create() method</h2>
<pre class="fragment">    &lt;b&gt;Purpose&lt;/b&gt;

    The Create() method creates a production node from available production 
    node alternatives of the same type. For example, if you call the 
    Create() method of an ImageGenerator object, on successful execution the 
    method returns a reference to an ImageGenerator node. 
</pre><div class="fragment"><div class="line"><a class="code" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a> Create (Context &amp;context, Query *pQuery=NULL, EnumerationErrors *pErrors=NULL)</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Context</td><td>Context in which to create the production node. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pQuery</td><td>Optional. Filters the production node alternatives. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pErrors</td><td>Optional. Returns information about production nodes that could not be created. <pre class="fragment">    &lt;b&gt;Remarks&lt;/b&gt;

    In order to create any type of production node (e.g., a UserGenerator 
    node) the application calls this method of the instantiated production 
    object (e.g., a UserGenerator object). However, an appropriate OpenNI 
    module (plug-in) must first be installed on the computer to provide that 
    required type of production node (e.g., a UserGenerator node). 

    This method enumerates all available production node alternatives, 
    taking into account any defined query. The method selects any one of the 
    matching node alternatives it has found, in order to create the required 
    type of production node. 

    By default, if an existing node matches the filter, the Create() method 
    will return a reference to the existing node, and so it will not create 
    a new node. 

    If no query is defined, this method uses any available node alternative 
    to create the node. Thus in this case, no assumption can be made about 
    which of the available production node alternatives the method will 
    select to create the new node. 

    To fine control the selection the application can define an appropriate 
    query to narrow down the number of production node alternatives for 
    creating the required production node, so that only matching nodes will 
    be considered for selection. 

    The Create() method is equivalent to calling EnumerateProductionTrees() 
    followed by CreateProductionTree() on the first result. That is, to call 
    CreateProductionTree() on the first production node alternative that 
    EnumerateProductionTrees() returns. 

    On successful execution, the production object (e.g., the UserGenerator 
    object) references the newly created production node (e.g., a 
    UserGenerator node). The application can then use the other methods of 
    the node. 

    The production node that is returned is always a complete production 
    graph. That is to say, the returned node will bring with it all other 
    dependant nodes it requires for generating its output data. For example, 
    if the required production node is a UserGenerator node, and its 
    dependencies include a DepthGenerator node, then the new UserGenerator 
    node reference will also bring with it a reference to a DepthGenerator 
    node, creating a new DepthGenerator node if necessary. 

    If the production node returned is the base of a production graph 
    (e.g., a Device node), then it does not have any dependencies and so the 
    node will not bring with it any associated nodes at all. In this case 
    the length and breadth of the returned production graph will be just the 
    single new node reference. </pre> </td></tr>
  </table>
  </dd>
</dl>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Nov 12 2013 13:40:21 for OpenNI 1.5.7 by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.3.1
</small></address>
</body>
</html>
