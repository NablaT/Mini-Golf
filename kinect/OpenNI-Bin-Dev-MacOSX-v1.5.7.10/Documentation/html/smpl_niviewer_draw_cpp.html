<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>OpenNI 1.5.7: Draw.cpp file</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="OpenNILogo.bmp"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">OpenNI 1.5.7
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="index.html">OpenNI Overview</a></li><li class="navelem"><a class="el" href="smpls_n_guides.html">Samples and Guides</a></li><li class="navelem"><a class="el" href="smpls.html">Sample Programs for the OpenNI API</a></li><li class="navelem"><a class="el" href="smpl_niviewer.html">NiViewer - sample program</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Draw.cpp file </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><pre class="fragment">    &lt;b&gt;Source files:&lt;/b&gt; Click the following link to view the source code file:
        - Draw.cpp

This file contains the code for displaying the frames from the OpenNI generator nodes. 
</pre><h1><a class="anchor" id="draw_cpp_glb_decls"></a>
Global Type Declarations for Capture.cpp</h1>
<pre class="fragment">    There are no OpenNI specific golbal declarations. 
</pre><h1><a class="anchor" id="draw_cpp_fns_getpoweroftwo_to_setErrorState"></a>
Functions GetPowerOfTwo() to setErrorState()</h1>
<pre class="fragment">    There are no OpenNI specific operations in these functions. 
</pre><h1><a class="anchor" id="draw_cpp_drawcropstream"></a>
Function: drawCropStream() - Draws a Cropped Map from the Generator nodes</h1>
<pre class="fragment">    This function draws a cropped map from each of the generator nodes.

    &lt;b&gt;Parameters:&lt;/b&gt;

        &lt;code&gt;pGenerator&lt;/code&gt;: Specifies one of the three map generator nodes: DepthGenerator, ImageGenerator node, or ImageGenerator node.

    First of all this function calls @ref xn::Generator::IsCapabilitySupported() to check whether this OpenNI installation supports a cropping capability.
</pre> <div class="fragment"><div class="line"><span class="keywordflow">if</span> (!pGenerator-&gt;IsCapabilitySupported(<a class="code" href="_xn_types_8h.html#adb1d497ae3a6ced5a4fa52182fa2b6e1">XN_CAPABILITY_CROPPING</a>))</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><p>This function calls <a class="el" href="classxn_1_1_map_generator.html#a1fd1a64c376d7a47b2951bd996939644">xn::MapGenerator::GetMapOutputMode()</a> to get the Generator node's map output mode, which contains the node's current frame dimensions. the map output mode is obtaiend as an <a class="el" href="_xn_types_8h.html#aaa3272a330652ec83d7bf5330418c55c">XnMapOutputMode</a> structure. The frame dimensions are needed for drawing the map on the graphic display. </p>
<div class="fragment"><div class="line"><a class="code" href="struct_xn_map_output_mode.html">XnMapOutputMode</a> Mode;</div>
<div class="line">pGenerator-&gt;GetMapOutputMode(Mode);     </div>
</div><!-- fragment --><p>An OpenNI <a class="el" href="_xn_types_8h.html#abcf66e9732cef012b3127a4d3d373b98">xn::XnCropping</a> structure is used for containing the cropping location. Its fields are shown in the code block below. </p>
<div class="fragment"><div class="line"><a class="code" href="struct_xn_cropping.html">XnCropping</a> cropping;</div>
<div class="line">cropping.<a class="code" href="struct_xn_cropping.html#a9fe787dba0082b97e01d2bbf95c3be6a">bEnabled</a> = <a class="code" href="_xn_platform_8h.html#aa8cecfc5c5c054d2875c03e77b7be15d">TRUE</a>;</div>
<div class="line">cropping.<a class="code" href="struct_xn_cropping.html#a15dc3646d14d2dca176b306d675af223">nXOffset</a> = cropRect.uLeft;</div>
<div class="line">cropping.<a class="code" href="struct_xn_cropping.html#a7b33ecb40598d92ecc19a152e5b8e9ba">nYOffset</a> = cropRect.uBottom;</div>
<div class="line">cropping.<a class="code" href="struct_xn_cropping.html#ae1d6a8702c62d653271e2021acc73c8e">nXSize</a> = cropRect.uRight - cropRect.uLeft;</div>
<div class="line">cropping.<a class="code" href="struct_xn_cropping.html#ad154d03ef91067018261a55af94294e0">nYSize</a> = cropRect.uTop - cropRect.uBottom;</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">if</span> ((cropping.<a class="code" href="struct_xn_cropping.html#a15dc3646d14d2dca176b306d675af223">nXOffset</a> % dividedBy) != 0)</div>
<div class="line">    cropping.<a class="code" href="struct_xn_cropping.html#a15dc3646d14d2dca176b306d675af223">nXOffset</a> -= (cropping.<a class="code" href="struct_xn_cropping.html#a15dc3646d14d2dca176b306d675af223">nXOffset</a> % dividedBy);</div>
<div class="line"><span class="keywordflow">if</span> ((cropping.<a class="code" href="struct_xn_cropping.html#ae1d6a8702c62d653271e2021acc73c8e">nXSize</a> % dividedBy) != 0)</div>
<div class="line">    cropping.<a class="code" href="struct_xn_cropping.html#ae1d6a8702c62d653271e2021acc73c8e">nXSize</a> += dividedBy - (cropping.<a class="code" href="struct_xn_cropping.html#ae1d6a8702c62d653271e2021acc73c8e">nXSize</a></div>
</div><!-- fragment --><p>Finally, the function assigns the cropping setting to the Generator node. To do this it calls <a class="el" href="smpl_niviewer_device_cpp.html#device_cpp_setStreamCropping">&lt;code&gt;setStreamCropping()&lt;/code&gt;</a>, which si defined in the <code>Device.cpp</code> file of this sample program.</p>
<h1><a class="anchor" id="draw_cpp_drawSelectionChanged"></a>
Function: drawSelectionChanged() - Callback invoked when Draw Selection has Changed</h1>
<pre class="fragment">    This callback is invoked when the draw selection has been changed.

    This callback calls the @ref draw_cpp_drawcropstream function defined above for each valid Generator node. For example:
</pre> <div class="fragment"><div class="line"><span class="keywordflow">if</span> (getDepthGenerator() != NULL &amp;&amp; g_DrawConfig.Streams.Depth.Coloring != DEPTH_OFF)</div>
<div class="line">{</div>
<div class="line">    drawCropStream(getDepthGenerator(), g_DrawConfig.DepthLocation, selection, 2);</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="draw_cpp_calculateHistogram"></a>
Function: calculateHistogram() - Calculates Depth Histogram</h1>
<pre class="fragment">    This function uses the depth values to build an accumulative histogram of frequency of occurrence of each depth value. The *pDepth pointer accesses each value in the depth buffer. It then uses the value as an index into the g_pDepthHist histogram array.
</pre><h1><a class="anchor" id="draw_cpp_YUV422ToRGB888"></a>
Function: YUV422ToRGB888() - Converts Formats</h1>
<pre class="fragment">    There are no OpenNI operations in this function.
</pre> <div class="fragment"><div class="line"><span class="comment">// --------------------------------</span></div>
<div class="line"><span class="comment">// Drawing</span></div>
<div class="line"><span class="comment">// --------------------------------</span></div>
<div class="line"><span class="preprocessor">#if (XN_PLATFORM == XN_PLATFORM_WIN32)</span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line"><span class="keywordtype">void</span> YUV422ToRGB888(<span class="keyword">const</span> XnUInt8* pYUVImage, XnUInt8* pRGBAImage, XnUInt32 nYUVSize, XnUInt32 nRGBSize)</div>
<div class="line">{       </div>
<div class="line">    ...</div>
<div class="line">    ...</div>
</div><!-- fragment --><h1><a class="anchor" id="draw_cpp_drawClosedStream"></a>
Function: drawClosedStream() - Converts Formats</h1>
<pre class="fragment">    There are no OpenNI operations in this function.
</pre><h1><a class="anchor" id="draw_cpp_drawColorImage"></a>
Function: drawColorImage() - Draws the Color Image Map</h1>
<pre class="fragment">    This function draws the color image map for either the ImageGenerator map or the IRGenerator node.

    This function gets saved @ref glos_frame_object "frame objects", assigning them to &lt;code&gt;pImageMD&lt;/code&gt; and draws them to the graphic display. The frame object is a snapshot of the generated data, saved as a metadata object, at a certain point in time. The @ref xn::OutputMetaData::Data() method gets a pointer to the data frame of the frame object saved in the metadata. 
</pre> <div class="fragment"><div class="line"><span class="keywordflow">if</span> (isImageOn())</div>
<div class="line">{</div>
<div class="line">    pImageMD = getImageMetaData();</div>
<div class="line">    pImage = getImageMetaData()-&gt;Data();</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">else</span> <span class="keywordflow">if</span> (isIROn())</div>
<div class="line">{</div>
<div class="line">    pImageMD = getIRMetaData();</div>
<div class="line">    pImage = (<span class="keyword">const</span> XnUInt8*)getIRMetaData()-&gt;Data();</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">else</span></div>
<div class="line">    <span class="keywordflow">return</span>;     </div>
</div><!-- fragment --><p>The code block above gets a pointer to the data frame of the frame object saved in the metadata. The frame object is a snapshot of the generated data at a certain point in time.</p>
<p>The main draw operations are controlled by the following for-loop. </p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (XnUInt16 nY = pImageMD-&gt;YOffset(); nY &lt; pImageMD-&gt;YRes() + pImageMD-&gt;YOffset(); nY++)</div>
<div class="line">{</div>
<div class="line">    XnUInt8* pTexture = TextureMapGetLine(&amp;g_texImage, nY) + pImageMD-&gt;XOffset()*4;</div>
<div class="line">    ...</div>
<div class="line">    ...</div>
</div><!-- fragment --><p>The above loop provides the y indexes to access each pixel in the <code>DepthMap</code>. The <a class="el" href="classxn_1_1_map.html#a12df2e51951f42f4265e27e14d8d412b">YRes()</a> method returns the Y dimension &ndash; height &ndash; of the data frame.</p>
<p>The following code uses the FullXRes() to calculate the scaling factor between the depth map and the GL window. FullXRes() gets the full frame resolution, i.e., the entire field-of-view, ignoring cropping of the FOV in the scene. </p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (pDepthMetaData != NULL)</div>
<div class="line">{</div>
<div class="line">    XnDouble dRealX = (nX + pImageMD-&gt;XOffset()) / (XnDouble)pImageMD-&gt;FullXRes();</div>
<div class="line">    XnDouble dRealY = nY / (XnDouble)pImageMD-&gt;FullYRes();</div>
<div class="line"></div>
<div class="line">    XnUInt32 nDepthX = dRealX * pDepthMetaData-&gt;FullXRes() - pDepthMetaData-&gt;XOffset();</div>
<div class="line">    XnUInt32 nDepthY = dRealY * pDepthMetaData-&gt;FullYRes() - pDepthMetaData-&gt;YOffset();</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (nDepthX &gt;= pDepthMetaData-&gt;XRes() || nDepthY &gt;= pDepthMetaData-&gt;YRes())</div>
<div class="line">    {</div>
<div class="line">        nDepthIndex = -1;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span></div>
<div class="line">    {</div>
<div class="line">        nDepthIndex = nDepthY*pDepthMetaData-&gt;XRes() + nDepthX;</div>
<div class="line">    }</div>
<div class="line">}       </div>
</div><!-- fragment --><h1><a class="anchor" id="draw_cpp_drawDepth"></a>
Function: drawDepth() - Draws the Depth Map</h1>
<pre class="fragment">    This function is implemented in a way similar to that of the draw_cpp_drawColorImage function above.

    Of note is the &lt;&gt;&lt;code&gt;++pDepth&lt;/code&gt; term in the code block below.
</pre> <div class="fragment"><div class="line"><span class="keywordflow">for</span> (XnUInt16 nY = pDepthMD-&gt;YOffset(); nY &lt; pDepthMD-&gt;YRes() + pDepthMD-&gt;YOffset(); nY++)</div>
<div class="line">{</div>
<div class="line">    XnUInt8* pTexture = TextureMapGetLine(&amp;g_texDepth, nY) + pDepthMD-&gt;XOffset()*4;</div>
<div class="line">    <span class="keywordflow">for</span> (XnUInt16 nX = 0; nX &lt; pDepthMD-&gt;XRes(); nX++, pDepth++, pTexture+=4)</div>
</div><!-- fragment --><p><b><code>++pDepth</code>:</b> This pointer is incremented by 1 for each inner loop. So it steps through all the pixels in the Depth map. Thus the program can get each pixel's depth value. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Nov 12 2013 13:40:21 for OpenNI 1.5.7 by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.3.1
</small></address>
</body>
</html>
