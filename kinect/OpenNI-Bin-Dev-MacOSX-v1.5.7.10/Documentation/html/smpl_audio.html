<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>OpenNI 1.5.7: NiAudioSample.cpp - sample program</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="OpenNILogo.bmp"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">OpenNI 1.5.7
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="index.html">OpenNI Overview</a></li><li class="navelem"><a class="el" href="smpls_n_guides.html">Samples and Guides</a></li><li class="navelem"><a class="el" href="smpls.html">Sample Programs for the OpenNI API</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">NiAudioSample.cpp - sample program </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><pre class="fragment">&lt;b&gt;Source file:&lt;/b&gt; Click the following link to view the source code file:
    - NiAudioSample.cpp 

This section describes an OpenNI sample program for using the Audio interface.

The documentation describes the sample program's code from the top of the program file(s) to bottom.

This documentation item describes only OpenNI code features. Third party features, e.g., GL code, may be ignored. However, place holders as section headings appear in place of complete functions or large code blocks that are not OpenNI specific or key to understanding the logic of the sample program. These place holders are section headings with minimal text to enable the reader to identify the original program structure when studying the documentation.

Every OpenNI feature is described the first time it appears in this sample program. Further appearances of the same feature are not described again.    
</pre><h1><a class="anchor" id="bkrec_macros"></a>
Macro Declarations</h1>
<pre class="fragment">    At the top of the program is a macro utility declaration, which calls OpenNI methods. It is described below. However, for the sake of conciseness, the rest of this documentation skips calls to this macro.

    The CHECK_RC() macro checks whether the most recent OpenNI operation was successful or returned an error result. On error, the @ref xn::xnGetStatusString "xnGetStatusString()" method converts the OpenNI error return code to the corresponding error string for printing, and the current function exits.
</pre> <div class="fragment"><div class="line"><span class="preprocessor">#define CHECK_RC(rc, what) \</span></div>
<div class="line"><span class="preprocessor">    if (rc != XN_STATUS_OK)                                     \</span></div>
<div class="line"><span class="preprocessor">    {                                                           \</span></div>
<div class="line"><span class="preprocessor">        printf(&quot;%s failed: %s\n&quot;, what, xnGetStatusString(rc)); \</span></div>
<div class="line"><span class="preprocessor">        return rc;                                              \</span></div>
<div class="line"><span class="preprocessor">    }</span></div>
</div><!-- fragment --><h1><a class="anchor" id="rec_syn_sample_xml_path"></a>
Declaration of File Path</h1>
<pre class="fragment">    In the following definitions, SAMPLE_XML_PATH is for the path to an OpenNI XML script input file for building a production graph. The &lt;i&gt;production graph&lt;/i&gt; is a network of &lt;i&gt;production nodes&lt;/i&gt; and is the principal OpenNI object model. See @ref prod_graph for more about the production graph.
</pre> <div class="fragment"><div class="line"><span class="preprocessor">#define SAMPLE_XML_PATH &quot;../../../../Data/SamplesConfig.xml&quot;</span></div>
</div><!-- fragment --><h1><a class="anchor" id="aud_glb_dcl_blk_ref"></a>
"Declaration Block" section</h1>
<pre class="fragment">    The reader may find it convenient to study the global declaration block before continuing to study the code statements. The global declaration block is documented later in this section, corresponding to its position in the program file &amp;ndash; see @ref aud_glb_dcl_blk.
</pre><h1><a class="anchor" id="aud_decl_mode"></a>
enum Mode</h1>
<pre class="fragment">    The following declaration defines the  program mode, whether whether it is recording an OpenNI data generation session or whether  it is playing a recording.
</pre> <div class="fragment"><div class="line"><span class="keyword">enum</span> Mode</div>
<div class="line">{</div>
<div class="line">    MODE_PLAY,</div>
<div class="line">    MODE_RECORD,</div>
<div class="line">};</div>
</div><!-- fragment --><p>This declaration is not OpenNI specific.</p>
<h1><a class="anchor" id="aud_printusage"></a>
printUsage() method</h1>
<pre class="fragment">    This function is not OpenNI specific.       
</pre><h1><a class="anchor" id="aud_play"></a>
play() method - Play Audio</h1>
<pre class="fragment">    This routine gets an array of AudioGenerators, takes the first one, and constantly reads data from it and sends it to be played.

    The following code block gets the first AudioGenerator node's wave output mode. It is received in an xn::XnWaveOutputMode, which comprises: bits per sample, channel, and sample rate. This information is then used for setting up the audio output buffers for collecting the generated play data and for setting up the hardware audio output channel.
</pre> <div class="fragment"><div class="line"><a class="code" href="struct_xn_wave_output_mode.html">XnWaveOutputMode</a> waveMode;</div>
<div class="line">nRetVal = aGens[0].GetWaveOutputMode(waveMode);</div>
<div class="line">CHECK_RC(nRetVal, <span class="stringliteral">&quot;Failed getting wave output mode&quot;</span>);</div>
</div><!-- fragment --><p>The above completes the initialization. The following code is the main program loop.</p>
<p>The application calls an 'Update Data()' method, in this case the node's <a class="el" href="classxn_1_1_generator.html#aaf3162a87a79a05fa655f344c835fa2e">WaitAndUpdateData</a>, to make a new frame available for getting. The application can then get the data (for example, using a metadata GetData() method). </p>
<div class="fragment"><div class="line">nRetVal = aGens[0].WaitAndUpdateData();</div>
</div><!-- fragment --><p>Assuming the above call succeeded, the application then gets the size of the audio data that was generated by the AudioGenerator node. </p>
<div class="fragment"><div class="line">XnUInt32 nBufferSize = aGens[0].GetDataSize();</div>
</div><!-- fragment --><p>The next OpenNI statements copy the AudioGenerator node's data into a prepared buffer to be sent to the machine sound card. <code>xnOSMemCopy</code> is OpenNI memory copy routine. </p>
<div class="fragment"><div class="line"><a class="code" href="_xn_o_s_memory_8h.html#ac0ba7022d7d4f6e1859dd7ce02c18589">xnOSMemCopy</a>(pHeader-&gt;lpData, aGens[0].GetAudioBuffer(), nBufferSize);</div>
<div class="line">pHeader-&gt;dwBufferLength = nBufferSize;</div>
</div><!-- fragment --><h1><a class="anchor" id="aud_record"></a>
record() method - Record Audio</h1>
<pre class="fragment">    This method gets a list of audio generators, and records to a separate file the data generated by each generator .  
    The following code block creates files named with the names of the AudioGenerator nodes.
</pre> <div class="fragment"><div class="line">XN_FILE_HANDLE aFiles[nSupportedNodes];</div>
<div class="line"><span class="keywordflow">for</span> (XnUInt32 i = 0; i &lt; nNodes; ++i)</div>
<div class="line">{</div>
<div class="line">    XnChar strFileName[XN_FILE_MAX_PATH];</div>
<div class="line">    sprintf(strFileName, <span class="stringliteral">&quot;audio.%s.pcm&quot;</span>, aGens[i].GetName());</div>
<div class="line">    nRetVal = <a class="code" href="_xn_o_s_8h.html#abb52a6771e3911589e247d2a37582dd8">xnOSOpenFile</a>(strFileName, <a class="code" href="_xn_o_s_8h.html#ada81ca1478bc791760a0191155cf57b3">XN_OS_FILE_WRITE</a>, &amp;aFiles[i]);</div>
<div class="line">    CHECK_RC(nRetVal, <span class="stringliteral">&quot;Open file&quot;</span>);</div>
<div class="line">}</div>
</div><!-- fragment --><p>The application then calls an <a class="el" href="conc_updating_data.html">'Update Data'</a> method, in this case <a class="el" href="classxn_1_1_context.html#a17fab043d7b6d60728511527a1d5c090" title="Updates all generator nodes in the context to their latest available data, first waiting for any of t...">xn::Context.WaitAnyUpdateAll()</a>, to update all generator nodes in the context to the latest available data, first waiting for any of the nodes to have new data available. The first call is used just to flush the node. </p>
<div class="fragment"><div class="line">context.WaitAnyUpdateAll();</div>
</div><!-- fragment --><p>The following loop checks which node has new data and writes it to a file. The IsDataNew() method returns whether a node's frame data was updated by the most recent call to the WaitAnyUpdateAll() method. </p>
<div class="fragment"><div class="line">XN_FILE_HANDLE aFiles[nSupportedNodes];</div>
<div class="line">   ...</div>
<div class="line">   ...</div>
<div class="line">for (XnUInt32 i = 0; i &lt; nNodes; ++i)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> (aGens[i].IsDataNew())</div>
<div class="line">    {</div>
<div class="line">        nRetVal = <a class="code" href="_xn_o_s_8h.html#ad4b47cf7442bd78d88b7c01e89347099">xnOSWriteFile</a>(aFiles[i], aGens[i].GetAudioBuffer(), aGens[i].GetDataSize());</div>
<div class="line">        CHECK_RC(nRetVal, <span class="stringliteral">&quot;Write to file&quot;</span>);</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="aud_mainprg"></a>
Main Program</h1>
<h2><a class="anchor" id="aud_glb_dcl_blk"></a>
"Declaration Block" section</h2>
<pre class="fragment">        The declaration block at the top of the main program declares a @ref xn::Context object, an @ref xn::EnumerationErrors object, and an xn::ScriptNode object. The Context object is a workspace in which the application builds an OpenNI production graph. the @ref xn::EnumerationErrors object is for collecting errors from any of the OpenNI functions. Also declared is an OpenNI status flag for collecting return values from method calls. the @ref xn::ScriptNode object loads an XML script from a file or string, and then runs the XML script to build a production graph.      
</pre><div class="fragment"><div class="line"><a class="code" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a> nRetVal = <a class="code" href="_xn_status_8h.html#a92729089d8e28e740a3f8b5169c8f695">XN_STATUS_OK</a>;</div>
<div class="line">Context context;</div>
<div class="line">EnumerationErrors errors;</div>
<div class="line">  ...</div>
<div class="line">ScriptNode scriptNode;</div>
</div><!-- fragment --><h2><a class="anchor" id="aud_main_code"></a>
Main Code Section</h2>
<pre class="fragment">        In the following, the InitFromXmlFile() method is a shorthand combination of two other initialization methods &amp;ndash; Init() and then RunXmlScriptFromFile() &amp;ndash; which initializes the context object and then creates a production graph from an XML file. 
</pre> <div class="fragment"><div class="line">nRetVal = context.InitFromXmlFile(SAMPLE_XML_PATH, scriptNode);         </div>
</div><!-- fragment --><p>The following code block tests whether a production graph was created. If not, the reason is reported as a list of one or more errors in the <code>errors</code> object. </p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (nRetVal == XN_STATUS_NO_NODE_PRESENT)</div>
<div class="line">{</div>
<div class="line">    XnChar strError[1024];</div>
<div class="line">    errors.ToString(strError, 1024);</div>
<div class="line">    printf(<span class="stringliteral">&quot;%s\n&quot;</span>, strError);</div>
<div class="line">    <span class="keywordflow">return</span> (nRetVal);</div>
<div class="line">}</div>
</div><!-- fragment --><p>The following code block searches for <a class="el" href="classxn_1_1_audio_generator.html">xn::AudioGenerator</a> nodes in the production graph. The nodes are returned in the <a class="el" href="classxn_1_1_node_info_list.html">xn::NodeInfoList</a> object. This object is a list <a class="el" href="classxn_1_1_node_info.html">xn::NodeInfo</a> objects, each containing information about a node found in the above EnumerateExistingNodes() call.</p>
<div class="fragment"><div class="line">NodeInfoList list;</div>
<div class="line">nRetVal = context.EnumerateExistingNodes(list, <a class="code" href="_xn_types_8h.html#ac773bbb9817dac5ae1be0f380ec18b52a8303fcf880f5c311b1a370c83cae3da3">XN_NODE_TYPE_AUDIO</a>);</div>
<div class="line">CHECK_RC(nRetVal, <span class="stringliteral">&quot;Enumerate audio nodes&quot;</span>); </div>
<div class="line">AudioGenerator gens[nSupportedNodes];</div>
<div class="line">XnUInt32 nNodes = 0;</div>
</div><!-- fragment --><p>The following declarations and statements get all the <a class="el" href="classxn_1_1_audio_generator.html">xn::AudioGenerator</a> nodes that were found by the EnumerateExistingNodes() call. The <code>gens</code> array receives all the nodes, and they are counted by the <code>nNodes</code> variable. (Currently, only a single AudioGenerator node is supported for playing at at once.) </p>
<div class="fragment"><div class="line">AudioGenerator gens[nSupportedNodes];</div>
<div class="line">XnUInt32 nNodes = 0;</div>
<div class="line">   ...</div>
<div class="line">for (NodeInfoList::Iterator it = list.Begin(); it != list.End(); ++it)</div>
<div class="line">{</div>
<div class="line">    NodeInfo info = *it;</div>
<div class="line">    nRetVal = info.GetInstance(gens[nNodes]);</div>
<div class="line">    CHECK_RC(nRetVal, <span class="stringliteral">&quot;Get audio node&quot;</span>);</div>
<div class="line">    nNodes++;</div>
<div class="line">}</div>
</div><!-- fragment --> </div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Nov 12 2013 13:40:21 for OpenNI 1.5.7 by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.3.1
</small></address>
</body>
</html>
