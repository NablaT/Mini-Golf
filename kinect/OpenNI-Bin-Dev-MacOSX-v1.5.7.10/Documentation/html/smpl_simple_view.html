<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>OpenNI 1.5.7: NiSimpleViewer.cpp - sample program</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="OpenNILogo.bmp"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">OpenNI 1.5.7
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="index.html">OpenNI Overview</a></li><li class="navelem"><a class="el" href="smpls_n_guides.html">Samples and Guides</a></li><li class="navelem"><a class="el" href="smpls.html">Sample Programs for the OpenNI API</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">NiSimpleViewer.cpp - sample program </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><pre class="fragment">&lt;b&gt;Source file:&lt;/b&gt; Click the following link to view the source code file:
    - NiSimpleViewer.cpp

This section describes the SimpleViewer sample program. This sample program uses a DepthGenerator node and ImageGenerator node to build an accumulative histogram from depth values.
</pre><h1><a class="anchor" id="sv_glb_dcl_blk"></a>
Global Declaration Block</h1>
<pre class="fragment">    The following definition is for the path to an OpenNI XML script file for inputting and building a stored production graph. The &lt;i&gt;production graph&lt;/i&gt; is a network of &lt;i&gt;production nodes&lt;/i&gt; and is the principal OpenNI object model. The identifies blobs as hands or human users. 
</pre> <div class="fragment"><div class="line"><span class="preprocessor">#define SAMPLE_XML_PATH &quot;../../../../Data/SamplesConfig.xml&quot;</span></div>
</div><!-- fragment --><p>The following declares the array for the histogram array that is a key part of this sample program. (This is not OpenNI specific.) </p>
<div class="fragment"><div class="line"><span class="keywordtype">float</span> g_pDepthHist[MAX_DEPTH];</div>
</div><!-- fragment --><p>The following declaration block declares the OpenNI objects required for building the OpenNI production graph. </p>
<div class="fragment"><div class="line">Context g_context;</div>
<div class="line">ScriptNode g_scriptNode;</div>
<div class="line">DepthGenerator g_depth;</div>
<div class="line">ImageGenerator g_image;</div>
<div class="line">DepthMetaData g_depthMD;</div>
<div class="line">ImageMetaData g_imageMD;</div>
</div><!-- fragment --><p>Each of these declarations is described separately in the following paragraphs.</p>
<p>A <a class="el" href="classxn_1_1_context.html">Context</a> object is a workspace in which the application builds an OpenNI production graph.</p>
<p>The <a class="el" href="classxn_1_1_script_node.html">ScriptNode</a> object loads an XML script from a file or string, and then runs the XML script to build a production graph.</p>
<p>The <a class="el" href="classxn_1_1_depth_generator.html">DepthGenerator</a> node generates a depth map. Each map pixel value represents a distance from the sensor.</p>
<p>The <a class="el" href="classxn_1_1_image_generator.html">ImageGenerator</a> node generates color image maps of various formats, such as the RGB24 image format. Call its <a class="el" href="classxn_1_1_image_generator.html#a1297b84dcc77a2e81300d5fa17b3efec">SetPixelFormat()</a> method to set the image format to be generated.</p>
<p>The <a class="el" href="classxn_1_1_depth_meta_data.html">DepthMetaData</a> object provides a <a class="el" href="glossary.html#glos_frame_object">frame object</a> for the <a class="el" href="classxn_1_1_depth_generator.html">xn::DepthGenerator</a> node. A <a class="el" href="glossary.html#dict_gen_node">generator node's</a> <a class="el" href="glossary.html#glos_frame_object">frame object</a> contains a generated data frame and all its associated properties. This frame object, comprising the data frame and its properties, is accessible through the node's metadata object.</p>
<p>The <a class="el" href="classxn_1_1_image_meta_data.html">ImageMetaData</a> object provides a <a class="el" href="glossary.html#glos_frame_object">frame object</a> for the <a class="el" href="classxn_1_1_image_generator.html">xn::ImageGenerator</a> node. This metadata object is associated with an ImageGenerator node in the same way as the DepthMetaData object is associated with a DepthGenerator node.</p>
<h1><a class="anchor" id="sv_func_main"></a>
Main Program</h1>
<pre class="fragment">    The declarations at the top of the main program collect and report status and errors from any of the OpenNI functions.      
</pre> <div class="fragment"><div class="line"><a class="code" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a> rc;</div>
<div class="line">EnumerationErrors errors;</div>
</div><!-- fragment --><h2><a class="anchor" id="sv_scrpt_sets_up_pg"></a>
Use Script to Set up a Context and Production Graph</h2>
<pre class="fragment">        The @ref xn::Context::InitFromXmlFile() "InitFromXmlFile()" method is a shorthand combination of two other initialization methods &amp;mdash; @ref xn::Context::Init() "Init()" and then @ref xn::Context::RunXmlScriptFromFile() "RunXmlScriptFromFile()" &amp;mdash; which initializes the context object and then creates a production graph from an XML file. The XML script file describes all the nodes you want to create. For each node description in the XML file, this method creates a node in the production graph.        
</pre> <div class="fragment"><div class="line">rc = g_context.InitFromXmlFile(SAMPLE_XML_PATH, g_scriptNode, &amp;errors);</div>
</div><!-- fragment --><h2><a class="anchor" id="sv_ver_nodes_in_script"></a>
Verify Existence of Nodes in the Sample Script File</h2>
<pre class="fragment">        This is verification code to check that OpenNI found at least one node definition in the script file. The program continues execution only if at least one node definition if found. 
</pre> <div class="fragment"><div class="line"><span class="keywordflow">if</span> (rc == XN_STATUS_NO_NODE_PRESENT)</div>
<div class="line">{</div>
<div class="line">    XnChar strError[1024];</div>
<div class="line">    errors.ToString(strError, 1024);</div>
<div class="line">    printf(<span class="stringliteral">&quot;%s\n&quot;</span>, strError);</div>
<div class="line">    <span class="keywordflow">return</span> (rc);</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">else</span> <span class="keywordflow">if</span> (rc != <a class="code" href="_xn_status_8h.html#a92729089d8e28e740a3f8b5169c8f695">XN_STATUS_OK</a>)</div>
<div class="line">{</div>
<div class="line">    printf(<span class="stringliteral">&quot;Open failed: %s\n&quot;</span>, <a class="code" href="_xn_status_8h.html#a709a2190465f4a6d7893587e53d66798">xnGetStatusString</a>(rc));</div>
<div class="line">    <span class="keywordflow">return</span> (rc);</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="sv_get_dg_node_from_pg"></a>
Get a ImageGenerator Node from the Production Graph</h2>
<pre class="fragment">        Assuming that the above call to @ref xn::Context::InitFromXmlFile() "InitFromXmlFile()" succeeded, a production graph is then created. 

        The @ref xn::Context::FindExistingNode() "FindExistingNode()" method in the following code block tries to get a reference to any one of the production nodes. This call specifies XN_NODE_TYPE_DEPTH to get a reference to a @ref xn::DepthGenerator "DepthGenerator" node. A DepthGenerator node generates a depth map as an array of pixels, where each pixel is a depth value representing a distance from the sensor in millimeters. A reference to the node is returned in the depth parameter.   
</pre> <div class="fragment"><div class="line">rc = g_context.FindExistingNode(<a class="code" href="_xn_types_8h.html#ac773bbb9817dac5ae1be0f380ec18b52a1415a428ab99e92cebedd4fdb1fe74c6">XN_NODE_TYPE_DEPTH</a>, g_depth);</div>
</div><!-- fragment --><p>The code block that follows the FindExistingNode() call just checks that OpenNI found a DepthGenerator node in the production graph. </p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (rc != <a class="code" href="_xn_status_8h.html#a92729089d8e28e740a3f8b5169c8f695">XN_STATUS_OK</a>)</div>
<div class="line">{</div>
<div class="line">    printf(<span class="stringliteral">&quot;No depth node exists! Check your XML.&quot;</span>);</div>
<div class="line">    <span class="keywordflow">return</span> 1;</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="sv_get_dg_node_from_pg"></a>
Get a ImageGenerator Node from the Production Graph</h2>
<pre class="fragment">        The following code is similar to the previous code block, but this time the FindExistingNode() method call gets a reference to an @ref xn::ImageGenerator "ImageGenerator" node. Assuming that an ImageGenerator node was found, a reference to it is returned in the g_image parameter.            
</pre> <div class="fragment"><div class="line">rc = g_context.FindExistingNode(<a class="code" href="_xn_types_8h.html#ac773bbb9817dac5ae1be0f380ec18b52a6c93c4744f518c307c7c60f3b86937e4">XN_NODE_TYPE_IMAGE</a>, g_image);</div>
<div class="line"><span class="keywordflow">if</span> (rc != <a class="code" href="_xn_status_8h.html#a92729089d8e28e740a3f8b5169c8f695">XN_STATUS_OK</a>)</div>
<div class="line">{</div>
<div class="line">    printf(<span class="stringliteral">&quot;No image node exists! Check your XML.&quot;</span>);</div>
<div class="line">    <span class="keywordflow">return</span> 1;</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="sv_get_dg_data"></a>
Get the DepthGenerator's Data</h2>
<pre class="fragment">        The following statement gets the latest generated depth @ref glos_frame_object "frame object", saving it as a metadata object. 
</pre> <div class="fragment"><div class="line">g_depth.GetMetaData(g_depthMD);</div>
</div><!-- fragment --><h2><a class="anchor" id="sv_get_dg_latest"></a>
Get the ImageGenerator's Latest Data</h2>
<pre class="fragment">        This works the asme as for the  DepthGenerator as above.
</pre> <div class="fragment"><div class="line">g_image.GetMetaData(g_imageMD);</div>
</div><!-- fragment --><h2><a class="anchor" id="sv_chk_unsprted_mode"></a>
Checking for Unsupported Mode or Format</h2>
<pre class="fragment">        The following code block checks for Hybrid mode requirement. Hybrid mode isn't supported in this sample. This check accesses some attributes of the frame data's associated configuration properties: FullXRes() and FullYRes() are the full frame resolution, i.e., the entire field-of-view, ignoring cropping of the FOV in the scene.
</pre> <div class="fragment"><div class="line"><span class="keywordflow">if</span> (g_imageMD.FullXRes() != g_depthMD.FullXRes() || g_imageMD.FullYRes() != g_depthMD.FullYRes())</div>
<div class="line">{</div>
<div class="line">    printf (<span class="stringliteral">&quot;The device depth and image resolution must be equal!\n&quot;</span>);</div>
<div class="line">    <span class="keywordflow">return</span> 1;</div>
<div class="line">}</div>
</div><!-- fragment --><p>The following code block checks that the selected pixel format is RGB24. Other formats are not supported. if (g_imageMD.PixelFormat() != XN_PIXEL_FORMAT_RGB24) </p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (g_imageMD.PixelFormat() != <a class="code" href="_xn_types_8h.html#a1353b63052b435e150ca0f652539b431afc4300ee27b00fd2bfd6c9a581110543">XN_PIXEL_FORMAT_RGB24</a>)</div>
<div class="line">{</div>
<div class="line">    printf(<span class="stringliteral">&quot;The device image format must be RGB24\n&quot;</span>);</div>
<div class="line">    <span class="keywordflow">return</span> 1;</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="sv_init_texture_map"></a>
Initializing the Texture Map</h2>
<pre class="fragment">        The dimensions of the Texture Map buffer are calculated by rounding the full frame resolution of the DepthGenerator data frame. full frame resolution is accessed through xn::MapMetaData::FullXRes() "FullXRes()" and xn::MapMetaData::FullYRes() "FullYRes()"  (again, both accessed through the metadata frame object). 
</pre> <div class="fragment"><div class="line">g_nTexMapX = (((<span class="keywordtype">unsigned</span> short)(g_depthMD.FullXRes()-1) / 512) + 1) * 512;</div>
<div class="line">g_nTexMapY = (((<span class="keywordtype">unsigned</span> short)(g_depthMD.FullYRes()-1) / 512) + 1) * 512;</div>
<div class="line">g_pTexMap = (<a class="code" href="struct_xn_r_g_b24_pixel.html">XnRGB24Pixel</a>*)malloc(g_nTexMapX * g_nTexMapY * <span class="keyword">sizeof</span>(<a class="code" href="struct_xn_r_g_b24_pixel.html">XnRGB24Pixel</a>));</div>
</div><!-- fragment --><h1><a class="anchor" id="sv_func_glut_disp"></a>
glutDisplay()  - Display Control</h1>
<pre class="fragment">    Significant OpenNI programming is performed inside the glutDisplay() callback.
</pre><h2><a class="anchor" id="sv_read_fos"></a>
Read the Frame Objects</h2>
<pre class="fragment">        The following code blocks read the frame objects from the DepthGenerator and ImageGenerator nodes.

        the @ref xn::Context::WaitAnyUpdateAll() "WaitAnyUpdateAll()" method in the following statement updates all generator nodes in the context that have new data available, first waiting for a specified node to have new data available. The application can then get the data (for example, using a metadata GetData() method). This method has a timeout.      
</pre> <div class="fragment"><div class="line">nRetVal = context.WaitOneUpdateAll(depth);</div>
</div><!-- fragment --><p>The following code block calls the GetMetaData() methods of each of the two generator nodes to get the nodes' frame data from the frame objects &ndash; depthMD and g_imageMD, as already explained earlier.</p>
<p>The code then calls the Data() methods of each of the frame objects to get pointers &ndash; pDepth and pImage &ndash; into their respective map buffers. All further access to the data from the DepthGenerator and ImageGenerator nodes are through these frame objects. </p>
<div class="fragment"><div class="line">g_depth.GetMetaData(g_depthMD);</div>
<div class="line">g_image.GetMetaData(g_imageMD);</div>
<div class="line"><span class="keyword">const</span> <a class="code" href="_xn_types_8h.html#ad55e431b82556504d5c1c00d153156c9">XnDepthPixel</a>* pDepth = g_depthMD.Data();</div>
<div class="line"><span class="keyword">const</span> XnUInt8* pImage = g_imageMD.Data();</div>
</div><!-- fragment --><h2><a class="anchor" id="sv_scale_images"></a>
Scale the Images</h2>
<pre class="fragment">        The following code uses the FullXRes() to calculate the scaling factor between the depth map and the GL window. FullXRes() gets the full frame resolution, i.e., the entire field-of-view, ignoring cropping of the FOV in the scene.
</pre> <div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nImageScale = GL_WIN_SIZE_X / g_depthMD.FullXRes();</div>
</div><!-- fragment --><h2><a class="anchor" id="sv_build_histo"></a>
Using the Depth Values to Build an Accumulative Histogram</h2>
<pre class="fragment">        The program builds an &lt;i&gt;accumulative histogram&lt;/i&gt; in order to process the maps for increasing the contrast of areas of different depths so that areas closer to the sensor are brighter than areas further away from the sensor. The accumulative histogram achieves this by separating out areas of different depth values. 

    &lt;b&gt;Building the Initial Histogram: &lt;/b&gt; 

    The following code block builds a histogram of the depth map. It uses the depth values to build a histogram of frequency of occurrence of each depth value. 

    The &lt;code&gt;*pDepth&lt;/code&gt; pointer accesses each value in the depth map's frame object. 
    It then uses the value as an index into the &lt;code&gt;g_pDepthHist&lt;/code&gt; histogram array. 
</pre> <div class="fragment"><div class="line"><a class="code" href="_xn_o_s_memory_8h.html#ad0f2ea99cefaa47ac9750f8c434097de">xnOSMemSet</a>(g_pDepthHist, 0, MAX_DEPTH*<span class="keyword">sizeof</span>(<span class="keywordtype">float</span>));</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nNumberOfPoints = 0;</div>
<div class="line"><span class="keywordflow">for</span> (XnUInt y = 0; y &lt; g_depthMD.YRes(); ++y)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">for</span> (XnUInt x = 0; x &lt; g_depthMD.XRes(); ++x, ++pDepth) <span class="comment">// pDepth &#39;walks&#39; through the depth map, pixel by pixel</span></div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">if</span> (*pDepth != 0)   <span class="comment">// *pDepth accesses the depth value of the current depth pixel in the depth map</span></div>
<div class="line">        {                   <span class="comment">// A depth value of zero means no valid depth was obtained</span></div>
<div class="line">            g_pDepthHist[*pDepth]++; <span class="comment">// Increments the counter of the current depth value </span></div>
<div class="line">            nNumberOfPoints++;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p><b>Converting the histogram into a cumulative histogram: </b></p>
<p>The following processing loop converts the histogram into a cumulative histogram of frequency of occurrence of each depth value. The cumulative histogram is a histogram in which the vertical axis shows not just the counts for a single depth value, but instead &ndash; for each depth value &ndash; shows the counts for that depth value plus all counts for smaller depth values. The processing loop achieves this by making a running total of the counters of the depth values. Depth values whose counters reach relatively large numbers indicate blobs at those depths. The cumulative total always increases for all depth values each, faster when the depth values are encountered that represent the sides of a blob, and more slowly at a blob's peak. Thus, blobs at significantly different depths are separated out by the histogram to be at significantly different frequency levels. </p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> nIndex=1; nIndex&lt;MAX_DEPTH; nIndex++)</div>
<div class="line">{</div>
<div class="line">    g_pDepthHist[nIndex] += g_pDepthHist[nIndex-1];</div>
<div class="line">}</div>
</div><!-- fragment --><p>Note that at this stage a larger depth value means a greater distance of a human user from the sensor; accordingly, the higher cumulative frequency levels also mean a greater distance. Since we want a greater distance to be presented by a lower brightness (darker color), and a smaller distance to be represented by a greater brightness, then later in the code this direction must be reversed.</p>
<p>The following processing loop normalizes the cumulative histogram by dividing each counter by <code>nNumberOfPoints</code>, i.e., it converts every counter to a fraction of 1.</p>
<p>This loop also reverses the direction of the histogram - as explained above. This is the term: </p>
<div class="fragment"><div class="line">(1.0f - )</div>
</div><!-- fragment --><p>So now we have got the brightness factor we need: a smaller distance (depth) is represented by a greater cumulative count for a greater brightness, and larger distance (depth) is represented by a smaller cumulative count for a lower brightness.</p>
<p>The <code>(256 * )</code> multiplier and <code>(unsigned int)</code> cast then convert the brightness from a fraction of 1 to an integer between 0 and 255, which is exactly what is needed to directly create an RGB color later in this routine. </p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (nNumberOfPoints)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> nIndex=1; nIndex&lt;MAX_DEPTH; nIndex++)</div>
<div class="line">    {</div>
<div class="line">        g_pDepthHist[nIndex] = (<span class="keywordtype">unsigned</span> int)(256 * (1.0f - (g_pDepthHist[nIndex] / nNumberOfPoints)));</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>The histogram calculation has now been completed. We now have a <code>g_pDepthHist</code> array that when indexing it with a depth value returns you a brightness value that is (usually) significantly larger than the brightness value returned by indexing with a smaller depth value.</p>
<p><code>xnOSMemSet</code> is an OpenNI function that allocates and zeros. This OpenNI function calls the C++ <code>memset()</code> function. <code>g_pTexMap</code> is an area of memory used by the following code as a texture buffer for preparing a map to pass to GL for display on the monitor. </p>
<div class="fragment"><div class="line"><a class="code" href="_xn_o_s_memory_8h.html#ad0f2ea99cefaa47ac9750f8c434097de">xnOSMemSet</a>(g_pTexMap, 0, g_nTexMapX*g_nTexMapY*<span class="keyword">sizeof</span>(<a class="code" href="struct_xn_r_g_b24_pixel.html">XnRGB24Pixel</a>));</div>
</div><!-- fragment --><p><b>Preparing the Image Map and Depth Map for Output to GL: </b></p>
<p>The following two code blocks copy pixels from the OpenNI image map and depth map to the texture, <code>g_pTexMap</code>, in that order. These two code blocks declare a number of pointers that point into the <code>g_pTexMap</code> buffer.</p>
<p><em>See the diagram <a href="#NiSimpleViewer_Preparing_Maps_for_GL">"Preparing 
        the Image Map and Depth Map for Output to GL"</a></em>. This diagram clearly explains the following code blocks and the use of the pointers.</p>
<p>In the loops in the following two code blocks, <code>pTex</code> walks through the texture, <code>pImage</code> walks through the image map, and <code>pDepth</code> walks through the depth map.</p>
<p>Check if we need to draw an image frame to the texture. </p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (g_nViewState == DISPLAY_MODE_OVERLAY ||</div>
<div class="line">    g_nViewState == DISPLAY_MODE_IMAGE)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="struct_xn_r_g_b24_pixel.html">XnRGB24Pixel</a>* pImageRow = g_imageMD.RGB24Data();</div>
<div class="line">    <a class="code" href="struct_xn_r_g_b24_pixel.html">XnRGB24Pixel</a>* pTexRow = g_pTexMap + g_imageMD.YOffset() * g_nTexMapX;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">for</span> (XnUInt y = 0; y &lt; g_imageMD.YRes(); ++y)</div>
<div class="line">    {</div>
<div class="line">        <span class="keyword">const</span> <a class="code" href="struct_xn_r_g_b24_pixel.html">XnRGB24Pixel</a>* pImage = pImageRow;</div>
<div class="line">        <a class="code" href="struct_xn_r_g_b24_pixel.html">XnRGB24Pixel</a>* pTex = pTexRow + g_imageMD.XOffset();</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">for</span> (XnUInt x = 0; x &lt; g_imageMD.XRes(); ++x, ++pImage, ++pTex)</div>
<div class="line">        {</div>
<div class="line">            *pTex = *pImage;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        pImageRow += g_imageMD.XRes();</div>
<div class="line">        pTexRow += g_nTexMapX;</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>Check if we need to draw a depth frame to the texture. The depth value of each pixel, as converted by the accumulative histogram above, is displayed in a yellow shade. The accumulative histogram controls the brightness of the yellow color. Brighter colors represent areas closer to the hardware sensor.</p>
<p>In 'Overlay' mode (<code>g_nViewState == DISPLAY_MODE_OVERLAY)</code>, the depth pixels overwrite the image pixels inb the texture. The following code overwrites only pixels with a valid depth value <code>(*pDepth == 0)</code>. Program pixels with no valid depth value <code>(*pDepth != 0)</code> are left in their original color from the previous code block that writes out the image frame. </p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (g_nViewState == DISPLAY_MODE_OVERLAY ||</div>
<div class="line">    g_nViewState == DISPLAY_MODE_DEPTH)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="_xn_types_8h.html#ad55e431b82556504d5c1c00d153156c9">XnDepthPixel</a>* pDepthRow = g_depthMD.Data();</div>
<div class="line">    <a class="code" href="struct_xn_r_g_b24_pixel.html">XnRGB24Pixel</a>* pTexRow = g_pTexMap + g_depthMD.YOffset() * g_nTexMapX;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">for</span> (XnUInt y = 0; y &lt; g_depthMD.YRes(); ++y)</div>
<div class="line">    {</div>
<div class="line">        <span class="keyword">const</span> <a class="code" href="_xn_types_8h.html#ad55e431b82556504d5c1c00d153156c9">XnDepthPixel</a>* pDepth = pDepthRow;</div>
<div class="line">        <a class="code" href="struct_xn_r_g_b24_pixel.html">XnRGB24Pixel</a>* pTex = pTexRow + g_depthMD.XOffset();</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">for</span> (XnUInt x = 0; x &lt; g_depthMD.XRes(); ++x, ++pDepth, ++pTex)</div>
<div class="line">        {</div>
<div class="line">            <span class="keywordflow">if</span> (*pDepth != 0)</div>
<div class="line">            {</div>
<div class="line">                <span class="keywordtype">int</span> nHistValue = g_pDepthHist[*pDepth];</div>
<div class="line">                pTex-&gt;<a class="code" href="struct_xn_r_g_b24_pixel.html#abbb04a1b5d737d90e10a5975fc90eb87">nRed</a> = nHistValue;</div>
<div class="line">                pTex-&gt;<a class="code" href="struct_xn_r_g_b24_pixel.html#a9680d1b8556966a9db7556c0131ea03f">nGreen</a> = nHistValue;</div>
<div class="line">                pTex-&gt;<a class="code" href="struct_xn_r_g_b24_pixel.html#a9bbd69f246f9ec2d143f0c2802254a8b">nBlue</a> = 0;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        pDepthRow += g_depthMD.XRes();</div>
<div class="line">        pTexRow += g_nTexMapX;</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="NiSimpleViewer_Preparing_Maps_for_GL_sect"></a>
Preparing the Image Map and Depth Map for Output to GL</h1>
<p><a class="anchor" id="NiSimpleViewer_Preparing_Maps_for_GL"></a>"Preparing the Image Map and Depth Map for Output to GL".</p>
<div class="image">
<img src="NiSimpleViewer_Prep_Image_and_Depth_Maps_for_Output_to_GL.png" alt="NiSimpleViewer_Prep_Image_and_Depth_Maps_for_Output_to_GL.png"/>
</div>
 </div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Nov 12 2013 13:40:21 for OpenNI 1.5.7 by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.3.1
</small></address>
</body>
</html>
