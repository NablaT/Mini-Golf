<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>OpenNI 1.5.7: Device.cpp file</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="OpenNILogo.bmp"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">OpenNI 1.5.7
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="index.html">OpenNI Overview</a></li><li class="navelem"><a class="el" href="smpls_n_guides.html">Samples and Guides</a></li><li class="navelem"><a class="el" href="smpls.html">Sample Programs for the OpenNI API</a></li><li class="navelem"><a class="el" href="smpl_niviewer.html">NiViewer - sample program</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Device.cpp file </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><pre class="fragment">&lt;b&gt;Source files:&lt;/b&gt; Click the following link to view the source code file:
    - Device.cpp

This file contains the code for declaring, initalizing, and creating the basic OpenNI objects and nodes, and provides the basic access routiese. 
</pre><h1><a class="anchor" id="device_cpp_decls"></a>
Main File Declarations</h1>
<h1><a class="anchor" id="device_cpp_decls"></a>
Main File Declarations</h1>
<pre class="fragment">    The declarations at the head of this file define the main OpenNI objects and other environment variables.

    The following declarations define two of the main OpenNI objects required for building the OpenNI @ref prod_graph "production graph". The production graph is the main object in OpenNI.        
</pre> <div class="fragment"><div class="line">Context g_Context;</div>
<div class="line">ScriptNode g_scriptNode;</div>
</div><!-- fragment --><p>These two declarations are described separately in the following paragraphs.</p>
<p>the <a class="el" href="classxn_1_1_script_node.html">xn::ScriptNode</a> object loads an XML script from a file or string, and then runs the XML script to build a production graph.</p>
<p>The <em><a class="el" href="prod_graph.html">Production Graph</a></em> is a network of software objects - called production nodes - that can identify blobs as hands or human users. In this sample program the production graph identifies blobs as human users, and tracks them as they move.</p>
<p>a <a class="el" href="classxn_1_1_context.html">xn::Context</a> object is a workspace in which the application builds an OpenNI production graph.</p>
<p>The following declarations define some environment variables. They are not OpenNI related. </p>
<div class="fragment"><div class="line">DeviceStringProperty g_PrimaryStream;</div>
<div class="line">...</div>
</div><!-- fragment --><p>The following declarations define more main OpenNI objects. </p>
<div class="fragment"><div class="line">Device g_Device;</div>
<div class="line">DepthGenerator g_Depth;</div>
<div class="line">ImageGenerator g_Image;</div>
<div class="line">IRGenerator g_IR;</div>
<div class="line">AudioGenerator g_Audio;</div>
<div class="line">Player g_Player;</div>
</div><!-- fragment --><p> Each of these declarations is described separately in the following paragraphs.</p>
<p>A <a class="el" href="classxn_1_1_device.html">Device</a> node represents a physical hardware device currently connected in the system and used for generating data. The Device node represents the hardware device by providing, for example, the device's name, serial number, and specific vendors. The Device node itself does not generate data.</p>
<p>a <a class="el" href="classxn_1_1_depth_generator.html">xn::DepthGenerator</a> node generates a depth map. Each map pixel value represents a distance from the sensor. </p>
<div class="fragment"><div class="line">DepthGenerator depthGen;</div>
</div><!-- fragment --><p>A <a class="el" href="classxn_1_1_image_generator.html">ImageGenerator</a> node generates color image maps of various formats, such as the RGB24 image format. Call its <a class="el" href="classxn_1_1_image_generator.html#a1297b84dcc77a2e81300d5fa17b3efec">SetPixelFormat()</a> method to set the image format to be generated.</p>
<p>A <a class="el" href="classxn_1_1_i_r_generator.html">IRGenerator</a> node is a map generator that outputs infra-red maps. The IR Generator node supports all MapGenerator functionality, as well as adding additional functionality.</p>
<p>A <a class="el" href="classxn_1_1_audio_generator.html">AudioGenerator</a> node generates audio data.</p>
<p>A <a class="el" href="classxn_1_1_player.html">Player</a> node plays a saved recording of an OpenNI data generation session.</p>
<p>The following declarations define OpenNI use metadata classes to create <a class="el" href="conc_meta_data.html">frame objects</a>. The metadata classes provide <a class="el" href="glossary.html#glos_frame_object">frame objects</a> to the corresponding generator nodes to support fast data access. for example, the <a class="el" href="classxn_1_1_depth_meta_data.html">DepthMetaData</a> object provides a frame object for a <a class="el" href="classxn_1_1_depth_generator.html">DepthGenerator</a> node, and so on. </p>
<div class="fragment"><div class="line">DepthMetaData g_DepthMD;</div>
<div class="line">ImageMetaData g_ImageMD;</div>
<div class="line">IRMetaData g_irMD;</div>
<div class="line">AudioMetaData g_AudioMD;</div>
</div><!-- fragment --><p>This program file makes extensive use of <code>g_pPrimary</code>. This is a pointer to a <a class="el" href="classxn_1_1_production_node.html">ProductionNode</a> object to point to just one of the <a class="el" href="classxn_1_1_generator.html">Generator nodes</a>. This node is then termed the primary node in this sample program. <code>g_pPrimary</code> selectas which output map to display on the graphic display. <code>g_pPrimary</code> is assigned its value in the <code>changePrimaryStream()</code> function.</p>
<p>The ProductionNode class is a base class for all production nodes of the <a class="el" href="prod_graph.html">Production Graph</a>, including all <a class="el" href="classxn_1_1_generator.html">Generator</a> nodes. Note that the <code>g_pPrimary pointer</code> is never itself used to make an object or node, but just to point to a node created somewhere else. </p>
<div class="fragment"><div class="line">ProductionNode* g_pPrimary = NULL;</div>
</div><!-- fragment --><h1><a class="anchor" id="device_cpp_initConstants"></a>
- onErrorStateChanged() - Callback invoked when  the Error State Changed</h1>
<pre class="fragment">    In the following code block (shown in part), &lt;code&gt;g_PrimaryStream&lt;/code&gt; is initialized with the enum IDs of all different types of production nodes, e.g., @ref xn::XN_NODE_TYPE_DEPTH means a DepthGenerator node.
</pre> <div class="fragment"><div class="line">g_PrimaryStream.pValues[nIndex++] = <span class="stringliteral">&quot;Any&quot;</span>;</div>
<div class="line">g_PrimaryStream.pValues[nIndex++] = <a class="code" href="group__utils.html#ga57d1e3fba0d3cb73215fb0f963c906b7">xnProductionNodeTypeToString</a>(<a class="code" href="_xn_types_8h.html#ac773bbb9817dac5ae1be0f380ec18b52a1415a428ab99e92cebedd4fdb1fe74c6">XN_NODE_TYPE_DEPTH</a>);</div>
<div class="line">g_PrimaryStream.pValues[nIndex++] = <a class="code" href="group__utils.html#ga57d1e3fba0d3cb73215fb0f963c906b7">xnProductionNodeTypeToString</a>(<a class="code" href="_xn_types_8h.html#ac773bbb9817dac5ae1be0f380ec18b52a6c93c4744f518c307c7c60f3b86937e4">XN_NODE_TYPE_IMAGE</a>);</div>
<div class="line">g_PrimaryStream.pValues[nIndex++] = <a class="code" href="group__utils.html#ga57d1e3fba0d3cb73215fb0f963c906b7">xnProductionNodeTypeToString</a>(<a class="code" href="_xn_types_8h.html#ac773bbb9817dac5ae1be0f380ec18b52a521e7cfb9cf7fcdf6878d32904314c9c">XN_NODE_TYPE_IR</a>);</div>
<div class="line"> ...</div>
</div><!-- fragment --><p>In the following code block (shown in part), <code>g_Resolution</code> is initialized with all possible image map resolutions. </p>
<div class="fragment"><div class="line">g_Resolution.pValues[nIndex++] = <a class="code" href="_xn_types_8h.html#a18d0273b4dfc70b2798fae9d311fda9dad712ad6b5b4f84cd0d6fa66e2af8fcc2">XN_RES_QVGA</a>;</div>
<div class="line">g_Resolution.pValueToName[<a class="code" href="_xn_types_8h.html#a18d0273b4dfc70b2798fae9d311fda9dad712ad6b5b4f84cd0d6fa66e2af8fcc2">XN_RES_QVGA</a>] = Resolution(<a class="code" href="_xn_types_8h.html#a18d0273b4dfc70b2798fae9d311fda9dad712ad6b5b4f84cd0d6fa66e2af8fcc2">XN_RES_QVGA</a>).GetName();</div>
<div class="line">g_Resolution.pValues[nIndex++] = <a class="code" href="_xn_types_8h.html#a18d0273b4dfc70b2798fae9d311fda9da7e6cedba4ab9a309f459fad9367e5394">XN_RES_VGA</a>;</div>
<div class="line">g_Resolution.pValueToName[<a class="code" href="_xn_types_8h.html#a18d0273b4dfc70b2798fae9d311fda9da7e6cedba4ab9a309f459fad9367e5394">XN_RES_VGA</a>] = Resolution(<a class="code" href="_xn_types_8h.html#a18d0273b4dfc70b2798fae9d311fda9da7e6cedba4ab9a309f459fad9367e5394">XN_RES_VGA</a>).GetName();           </div>
</div><!-- fragment --><h1><a class="anchor" id="device_cpp_initConstants"></a>
- onErrorStateChanged() - Callback invoked when  the Error State Changed</h1>
<pre class="fragment">    This function tests whether the error state is now xn::XN_STATUS_OK, i.e., no error, or is an error. On error, the error message is accessed according to the value of @ref xn::XnStatus "errorState". The high word represents the error group of the  error. The low word is the sequential error number within the group. 
</pre><h1><a class="anchor" id="device_cpp_openCommon"></a>
- openCommon() - Common Initialize Function</h1>
<pre class="fragment">    This is a common initialize function called from a number of more specific functions that initialize the production graph.      
</pre> <div class="fragment"><div class="line"><span class="keywordtype">void</span> openCommon()</div>
<div class="line">{</div>
<div class="line">    ...</div>
<div class="line">}           </div>
</div><!-- fragment --><p>This function uses <a class="el" href="classxn_1_1_context.html#ac62acceb4c705d53380a56b85d0c8137">xn::Context::EnumerateExistingNodes</a> to enumerate for all production nodes defined in the production graph, which returns in the <code>list</code> return parameter a <a class="el" href="classxn_1_1_node_info_list.html">xn::NodeInfoList</a> containing all the context's existing created nodes. Each node is represented by a <a class="el" href="classxn_1_1_node_info.html">NodeInfo</a> object in the list.</p>
<p>The following for-loop iterates for all NodeInfo objects in the list. For each NodeInfo object found, this function calls <a class="el" href="classxn_1_1_node_info.html#a8ad87ca850fcfcc02108e85878a54892">GetInstance()</a> to return a reference to the actual production node instance represented by this NodeInfo object. The for-loop is shown below (in part): </p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (NodeInfoList::Iterator it = list.Begin(); it != list.End(); ++it)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">switch</span> ((*it).GetDescription().Type)</div>
<div class="line">    {</div>
<div class="line">    <span class="keywordflow">case</span> <a class="code" href="_xn_types_8h.html#ac773bbb9817dac5ae1be0f380ec18b52a3f3f170232645dd79fdbe7f7cc4e2097">XN_NODE_TYPE_DEVICE</a>:</div>
<div class="line">        (*it).GetInstance(g_Device);</div>
<div class="line">        <span class="keywordflow">break</span>;</div>
<div class="line">    <span class="keywordflow">case</span> <a class="code" href="_xn_types_8h.html#ac773bbb9817dac5ae1be0f380ec18b52a1415a428ab99e92cebedd4fdb1fe74c6">XN_NODE_TYPE_DEPTH</a>:</div>
<div class="line">        g_bIsDepthOn = <span class="keyword">true</span>;</div>
<div class="line">        (*it).GetInstance(g_Depth);</div>
<div class="line">        <span class="keywordflow">break</span>;</div>
<div class="line">    ...</div>
<div class="line">}</div>
</div><!-- fragment --><p>The above loop sets the generating state of all nodes to 'On', e.g., <code>g_bIsDepthOn = true</code>.</p>
<p>The following statement registers an event handler, <code>onErrorStateChanged()</code>, for all OpenNI errors that might occur. </p>
<div class="fragment"><div class="line">g_Context.RegisterToErrorStateChange(onErrorStateChanged, NULL, hDummy);</div>
</div><!-- fragment --><p>The following statements initialize the constants (see <a class="el" href="smpl_niviewer_device_cpp.html#device_cpp_initConstants"><ul>
<li>onErrorStateChanged() - Callback invoked when the Error State Changed</li>
</ul>
</a> above) and calls the <a class="el" href="smpl_niviewer_device_cpp.html#device_cpp_readFrame">readFrame()</a> method to read the first data frame. The readFrame() method reads the data frame from each and every one of all the generators in the production graph. </p>
<div class="fragment"><div class="line">initConstants();</div>
<div class="line">readFrame();</div>
</div><!-- fragment --><h1><a class="anchor" id="device_cpp_openDeviceFile"></a>
- openDeviceFile() - Builds a Production Graph from an OpenNI Recording File</h1>
<pre class="fragment">    This function sets up a replay of a session of OpenNI data generation exactly as it was recorded on an ONI file.

    The following call to the @ref xn::Context::Init() "Context::Init()" method builds the context's general software environment. This method initializes runtime variables and data structures, and examines all registered plug-ins to learn the purpose and specific capabilities of each. In particular, during initialization the context initialization examines all registered plug-ins to learn the purpose and specific capabilities of each.             
</pre> <div class="fragment"><div class="line"><a class="code" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a> nRetVal = g_Context.Init();</div>
</div><!-- fragment --><p>In the following, if <code>nRetVal</code> is an error value, the <a class="el" href="_xn_macros_8h.html#a6116e7b1f42e5ad6123f8fbb70b4bbca">XN_IS_STATUS_OK()</a> macro halts program execution, returning nRetVal as the error value. </p>
<div class="fragment"><div class="line"><a class="code" href="_xn_macros_8h.html#a6116e7b1f42e5ad6123f8fbb70b4bbca">XN_IS_STATUS_OK</a>(nRetVal);</div>
</div><!-- fragment --><p>The following call to <a class="el" href="classxn_1_1_context.html#a3589979f63d5b9ddea49b71dcdf9fc5a">OpenFileRecording()</a> recreates a production graph from a recorded ONI file and then replays the data generation exactly as it was recorded. The <code>csFile </code>parameter provides the name of the recorded file to be run. The <code>g_Player</code> parameter returns a <a class="el" href="classxn_1_1_production_node.html">xn::ProductionNode</a> object through which playback can be controlled, e.g., seeking and setting playback. </p>
<div class="fragment"><div class="line">nRetVal = g_Context.OpenFileRecording(csFile, g_Player);</div>
</div><!-- fragment --><p>The <code>openCommon()</code> method, called in the following statement, is descibed above in <a class="el" href="smpl_niviewer_device_cpp.html#device_cpp_openCommon"><ul>
<li>openCommon() - Common Initialize Function</li>
</ul>
</a>.</p>
<h1><a class="anchor" id="device_cpp_openDeviceFromXml"></a>
- openDeviceFromXml() - Builds a Production Graph from an OpenNI XML Script File</h1>
<pre class="fragment">    The following call to the @ref xn::Context::InitFromXmlFile() "Context.InitFromXmlFile()" method builds the context's general software environment (see &lt;code&gt;g_Context.Init()&lt;/code&gt; above) and then recreates a production graph from the specified OpenNI XML script file. This method is not for replaying a recording (compare with OpenFileRecording above).
</pre> <div class="fragment"><div class="line">nRetVal = g_Context.InitFromXmlFile(csXmlFile, g_scriptNode, &amp;errors);</div>
</div><!-- fragment --><p>In the following statement, if <code>nRetVal</code> is an error value, the <a class="el" href="_xn_macros_8h.html#a6116e7b1f42e5ad6123f8fbb70b4bbca">XN_IS_STATUS_OK()</a> macro halts program execution, returning nRetVal as the error value. </p>
<div class="fragment"><div class="line"><a class="code" href="_xn_macros_8h.html#a6116e7b1f42e5ad6123f8fbb70b4bbca">XN_IS_STATUS_OK</a>(nRetVal);</div>
</div><!-- fragment --><h1><a class="anchor" id="device_cpp_openDeviceFromXmlWithChoice"></a>
- openDeviceFromXmlWithChoice() - Builds a Production Graph from an XML Script, Allowing User to Select a Device</h1>
<pre class="fragment">    This function does the same as the previous function, i.e., it builds the Production Graph from an OpenNI XML Script File, but it allows the user to intervene and select a device.

    the @ref xn::Context::EnumerateProductionTrees() method enumerates all available production nodes for a specific node type (e.g., the application wants to create a @ref xn::Device node) and returns a full list of matching production nodes.

    This function then gets the device IDs of all the devices it finds in the production graph using xn::Device::GetIdentificationCap() "GetIdentificationCap()".

    The function then interacts with the user using simple C functions to allow the user to select which device to use.
</pre><h1><a class="anchor" id="device_cpp_closeDevice"></a>
- closeDevice() - Releases all the Production Nodes</h1>
<pre class="fragment">    This function releases all the production graph nodes.
</pre><h1><a class="anchor" id="device_cpp_readFrame"></a>
readFrame() function - Reads a Data frame from each Generator</h1>
<pre class="fragment">    This function reads a data frame from each of the generators in the production graph.

    If &lt;code&gt;g_pPrimary&lt;/code&gt; has been set to point to any particular node (i.e., not NULL; &lt;code&gt;g_pPrimary&lt;/code&gt; is initialized in the &lt;code&gt;changePrimaryStream()&lt;/code&gt; function) then this function calls @ref xn::Context::WaitOneUpdateAll() "WaitOneUpdateAll()" to wait only for that particular node to generate new data, and then this function refreshes the data available in all the nodes.

    &lt;code&gt;g_pPrimary&lt;/code&gt; can be pointing to NULL. This is a valid user selection, available from the GUI menu. &lt;code&gt;g_pPrimary&lt;/code&gt; == NULL means that the user is not selcting any particular generator node. 

    Then the function checks if all the node pointers (e.g., &lt;code&gt;g-depth&lt;/code&gt;) point to real nodes, and if so the function gets the node's @ref glos_frame_object "frame object", saving it in a metadata object. For example: the application saves a frame object from a  @ref xn::DepthGenerator "DepthGenerator" node as a ref xn::DepthMetaData object. 
</pre> <div class="fragment"><div class="line"><span class="keywordflow">if</span> (g_Depth.IsValid())</div>
<div class="line">{</div>
<div class="line">    g_Depth.GetMetaData(g_DepthMD);</div>
<div class="line">}</div>
</div><!-- fragment --><p> This frame object provides fast access to the saved generated data and its associated configuration.</p>
<h1><a class="anchor" id="device_cpp_changeRegistration"></a>
changeRegistration() - Changes the View Point Registration</h1>
<pre class="fragment">    &lt;i&gt;Viewpoint registration&lt;/i&gt; is an OpenNI term for performing the mathematical conversion of one node's coordinate system to match the coordinate system of another node.

    In this sample program, this specific function can toggle the viewpoint registration of the DepthGenerator node to that of the ImageGenerator node and back again - i.e., reset it - depending on the input parameter. This particular conversion is a consequence of the particular type of the supplied hardware sensor. 

    The following test checks verifies that the DepthGenerator node is a valid node and that it supports the Alternative View Point capability.
</pre> <div class="fragment"><div class="line"><span class="keywordflow">if</span> (!g_Depth.IsValid() || !g_Depth.IsCapabilitySupported(<a class="code" href="_xn_types_8h.html#ad58a593043ae5041ff5a1962184527a8">XN_CAPABILITY_ALTERNATIVE_VIEW_POINT</a>))</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span>;</div>
<div class="line">}               </div>
</div><!-- fragment --><p>The following code block calls <a class="el" href="classxn_1_1_alternative_view_point_capability.html">xn::AlternativeViewPointCapability</a> methods to toggle the viewpoint registration, as explained above. </p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (!nValue)</div>
<div class="line">{</div>
<div class="line">    g_Depth.GetAlternativeViewPointCap().ResetViewPoint();</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">else</span> <span class="keywordflow">if</span> (g_Image.IsValid())</div>
<div class="line">{</div>
<div class="line">    g_Depth.GetAlternativeViewPointCap().SetViewPoint(g_Image);</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="device_cpp_changePrimaryStream"></a>
changePrimaryStream() function - Change the Primary stream</h1>
<pre class="fragment">    This function selects from which node the application will take generated data. It selects the new production node acording to the index into the &lt;code&gt;g_PrimaryStream&lt;/code&gt; array. The @ref xnProductionNodeTypeFromString() function returns an enum specifting a particular node type, e.g., XN_NODE_TYPE_DEPTH specifies a DepthGenerator node.

    The user can invoke this functionality from the GUI user menu. The user can select a menu item to call this function.

    The following statement calls the  @ref xn::Context::CreateAnyProductionTree() method.
</pre><h1><a class="anchor" id="device_cpp_createStream"></a>
createStream() - Creates a New Data Generatation Node</h1>
<pre class="fragment">    This function creates a new stream by creating a new data generation node of a specified type calling the @ref xn::Context.CreateAnyProductionTree() method, as follows. 
</pre> <div class="fragment"><div class="line">EnumerationErrors errors;</div>
<div class="line"><a class="code" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a> nRetVal = g_Context.CreateAnyProductionTree(type, NULL, generator, &amp;errors);</div>
</div><!-- fragment --><p> This method enumerates for production nodes of a specific node type, and creates the first production node found of that type.</p>
<h1><a class="anchor" id="device_cpp_toggleStream"></a>
toggleStream() - Toggles between Starting and Stopping a Generator Node</h1>
<pre class="fragment">    This function toggles between starting and stopping a generator node. The first two statements ensure that the specified generator is a valid node, and if not it calls createStream() (described above) to create a node of the required type.

    In the following statement, the @ref xn::Generator::IsValid() method checks that the reference points to a real node instance, or to to NULL, where in the  latter case the function calls createStream() to create the generator node. 
</pre> <div class="fragment"><div class="line"><span class="keywordflow">if</span> (!generator.<a class="code" href="classxn_1_1_node_wrapper.html#a3927cf50a70b01c6a57be2e3cf976269" title="This method checks that this object points to an actual node (that has been &#39;created&#39;) and does not p...">IsValid</a>())</div>
<div class="line">{</div>
<div class="line">    createStream(generator, type);</div>
<div class="line">}</div>
</div><!-- fragment --><p>In the following code block, the <a class="el" href="classxn_1_1_generator.html#a5b1f69de8cfac0767729a4584778d7cf">IsGenerating()</a> method returns whether the node is currently in Generating state. <a class="el" href="classxn_1_1_generator.html#a4fa8a933a96765b30537b5203da3381e">StartGenerating()</a> enters the node into Generating state, and <a class="el" href="classxn_1_1_generator.html#ae955127df36f3c71e76bdc5f2e383065">StopGenerating()</a> makes the node leave Generating state (it enters Non-Generating state).</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (generator.<a class="code" href="classxn_1_1_generator.html#a5b1f69de8cfac0767729a4584778d7cf" title="Returns whether the node is currently in Generating state.">IsGenerating</a>())</div>
<div class="line">{</div>
<div class="line">    generator.<a class="code" href="classxn_1_1_generator.html#ae955127df36f3c71e76bdc5f2e383065" title="Makes the node leave Generating state (enters Non-Generating state).">StopGenerating</a>();</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">else</span></div>
<div class="line">{</div>
<div class="line">    generator.<a class="code" href="classxn_1_1_generator.html#a4fa8a933a96765b30537b5203da3381e" title="Enters the node into Generating state.">StartGenerating</a>();</div>
<div class="line">    ...</div>
<div class="line">}                       </div>
</div><!-- fragment --><p>After the application has called StartGenerating() it can call an 'Update Data()' method, e.g., <a class="el" href="classxn_1_1_generator.html#aaf3162a87a79a05fa655f344c835fa2e">xn::Generator::WaitAndUpdateData()</a>, to make a new frame available for getting. The application can then get the data (for example, using a metadata GetData() method, or some other mechanism depending on the type of node).</p>
<p>This <code>toggleStream()</code> function is used by a number of other functions to start and stop each of the generators in this application - see below.</p>
<p>Finally, this function then sets the boolean return parameter <code>bIsOn </code>from the <code>IsGenerating()</code> method. This parameter returns the updated 'Is Generating' state for all the 'Toggle Generating State' functions that follow below.</p>
<h1><a class="anchor" id="device_cpp_StartStopGen"></a>
Starting and Stopping each of the Generators</h1>
<pre class="fragment">    The following group of functions start and stop each of the generators in this application. 
</pre> <div class="fragment"><div class="line"><span class="keywordtype">void</span> toggleDepthState(<span class="keywordtype">int</span> nDummy)</div>
<div class="line">{</div>
<div class="line">    toggleStream(g_Depth, <a class="code" href="_xn_types_8h.html#ac773bbb9817dac5ae1be0f380ec18b52a1415a428ab99e92cebedd4fdb1fe74c6">XN_NODE_TYPE_DEPTH</a>, &amp;g_bIsDepthOn);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> toggleImageState(<span class="keywordtype">int</span> nDummy)</div>
<div class="line">{</div>
<div class="line">    toggleStream(g_Image, <a class="code" href="_xn_types_8h.html#ac773bbb9817dac5ae1be0f380ec18b52a6c93c4744f518c307c7c60f3b86937e4">XN_NODE_TYPE_IMAGE</a>, &amp;g_bIsImageOn);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> toggleIRState(<span class="keywordtype">int</span> nDummy)</div>
<div class="line">{</div>
<div class="line">    toggleStream(g_IR, <a class="code" href="_xn_types_8h.html#ac773bbb9817dac5ae1be0f380ec18b52a521e7cfb9cf7fcdf6878d32904314c9c">XN_NODE_TYPE_IR</a>, &amp;g_bIsIROn);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> toggleAudioState(<span class="keywordtype">int</span> nDummy)</div>
<div class="line">{</div>
<div class="line">    toggleStream(g_Audio, <a class="code" href="_xn_types_8h.html#ac773bbb9817dac5ae1be0f380ec18b52a8303fcf880f5c311b1a370c83cae3da3">XN_NODE_TYPE_AUDIO</a>, &amp;g_bIsAudioOn);</div>
<div class="line">}       </div>
</div><!-- fragment --><h1><a class="anchor" id="device_cpp_ToggleMirror"></a>
Function: toggleMirror() - Toggles the Global Mirror</h1>
<pre class="fragment">    This function can enable or disable the @ref xn::MirrorCapability "GlobalMirror" flag. For a detailed introduction to mirroring in OpenNI see @ref xn::MirrorCapability.

    The following statement gets the current value of the Global Mirror using the @ref xn::Context::GetGlobalMirror() "GetGlobalMirror()" method and then inverses it using the @ref xn::Context::GetGlobalMirror() "GetGlobalMirror()" method.
</pre> <div class="fragment"><div class="line"><a class="code" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a> nRetVal = g_Context.SetGlobalMirror(!g_Context.GetGlobalMirror())</div>
</div><!-- fragment --><p>Use the GUI menu access to toggle the GlobalMirrior.</p>
<h1><a class="anchor" id="device_cpp_seekFrame"></a>
Function: seekFrame() - Seeks a Data Frame in a Recording</h1>
<pre class="fragment">    This function seeks a data frame from the primary stream (generator node) in an OpenNI recording. 

    The first thing this function does is to get the node name of the primary stream. if the primary stream is found to be NULL, this function then gets node name of any other valid node.

    The following statement calls the @ref xn::Player::SeekToFrame() "SeekToFrame()" method to moves the player to a specific frame of a specific played node so that playing will continue from that frame onwards.
</pre> <div class="fragment"><div class="line">nRetVal = g_Player.SeekToFrame(strNodeName, nDiff, <a class="code" href="_xn_types_8h.html#a580ba965e8eac7ba5f5733e5e2f1ab51a20bfb449608c59f10e89657f3fced840">XN_PLAYER_SEEK_CUR</a>);</div>
</div><!-- fragment --><p>In the call above, the <code>nDiff</code> and <code><a class="el" href="_xn_types_8h.html#a580ba965e8eac7ba5f5733e5e2f1ab51a20bfb449608c59f10e89657f3fced840">xn::XN_PLAYER_SEEK_CUR</a></code> parameters specify that the seek operation moves <code>nDiff</code> frames from the current frame of the specified node. A positive value means to move forward, and a negative value means to move backwards.</p>
<p>In the following statement, the call to the <a class="el" href="classxn_1_1_player.html#acbb9e4ab391d0f0cabd8130f92c9e21d">TellFrame()</a> method gets the absolute current frame number of a specific node played by a player, i.e., the number of frames passed since the beginning of the recording.</p>
<p>In the following statement, the call to the <a class="el" href="classxn_1_1_player.html#a7de546636d6d721e07c366ec61a2feba">GetNumFrames()</a> method gets the number of frames of a specific node played by a player.</p>
<h1><a class="anchor" id="device_cpp_isgenon"></a>
Function: is 'Generator' On function</h1>
<pre class="fragment">    The following group of functions all return whether the production node is on. For example:
</pre> <div class="fragment"><div class="line"><span class="keywordtype">bool</span> isDepthOn()</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> (g_bIsDepthOn);</div>
<div class="line">}           </div>
</div><!-- fragment --><h1><a class="anchor" id="device_cpp_setResolution"></a>
Function: setResolution() - Sets the Resolution of the Output Map</h1>
<pre class="fragment">    This function sets the resolution component of the generator node's current map output mode. This map output mode includes the frame resolution, i.e., its X and Y dimensions, which are the number of elements in each of the X- and Y- axes) and also the frame rate. This is the map output mode that the generator node will use to generate its next data frame.

    The resolution is provided y the &lt;code&gt;res&lt;/code&gt; parameter to this function call, which is an enum value of type @ref xn::XnResolution "XnResolution", e.g., @ref xn::XN_RES_QVGA "XN_RES_QVGA". 

    The following code block calls the @ref xn::MapGenerator::GetMapOutputMode() "GetMapOutputMode()" method to get an @ref xn::XnMapOutputMode struct containing the generator node's current map output mode. The code then updates the mode's  resolution fields with new values, and then completes the operation by calling @ref xn::MapGenerator::SetMapOutputMode() "SetMapOutputMode()", passing the @ref xn::XnMapOutputMode struct as a parameter, to update the node's map output mode.
</pre> <div class="fragment"><div class="line"><a class="code" href="struct_xn_map_output_mode.html">XnMapOutputMode</a> Mode;</div>
<div class="line">pGenerator-&gt;GetMapOutputMode(Mode);</div>
<div class="line">Mode.<a class="code" href="struct_xn_map_output_mode.html#a069752554d19a7c2fb0ac9e49d3f02c8">nXRes</a> = Resolution((<a class="code" href="_xn_types_8h.html#a18d0273b4dfc70b2798fae9d311fda9d">XnResolution</a>)res).GetXResolution();</div>
<div class="line">Mode.<a class="code" href="struct_xn_map_output_mode.html#a25bc682450484d16acbfe7f16e0c2530">nYRes</a> = Resolution((<a class="code" href="_xn_types_8h.html#a18d0273b4dfc70b2798fae9d311fda9d">XnResolution</a>)res).GetYResolution();</div>
<div class="line"><a class="code" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a> nRetVal = pGenerator-&gt;SetMapOutputMode(Mode);</div>
</div><!-- fragment --><p>See also the setFPS() function (the next function, below) for setting the frame rate.</p>
<p>In the above, the 'Resolution' term is an OpenNI utility class for easy handling of resolution information. It creates a <a class="el" href="classxn_1_1_resolution.html">Resolution</a> object from an enum value of type <a class="el" href="_xn_types_8h.html#a73c4711a7a1935632e5336e6dd44c54a">XnResolution</a>, from which you can then get the X and Y dimensions if the frame.</p>
<h1><a class="anchor" id="device_cpp_setfps"></a>
Function: setFPS() - Selects a Resolution for the Output Map</h1>
<pre class="fragment">    This function sets the frame rate component of the generator node's current map output mode. 

    This function works in a similar way to the &lt;code&gt;setResolution()&lt;/code&gt; function above. 

    The following code block calls the @ref xn::MapGenerator::GetMapOutputMode() "GetMapOutputMode()" method to get an @ref xn::XnMapOutputMode struct containing the generator node's current map output mode. The code then updates the mode's  frmae rate field, &lt;code&gt;nFPS&lt;/code&gt;, with a new value, and then completes the operation by calling @ref xn::MapGenerator::SetMapOutputMode() "SetMapOutputMode()", passing the @ref xn::XnMapOutputMode struct as a parameter, to update the node's map output mode.
</pre> <div class="fragment"><div class="line"><a class="code" href="struct_xn_map_output_mode.html">XnMapOutputMode</a> Mode;</div>
<div class="line">pGenerator-&gt;GetMapOutputMode(Mode);</div>
<div class="line">Mode.<a class="code" href="struct_xn_map_output_mode.html#a59b47e091ebe2ad58749dc0609e4b870">nFPS</a> = fps;</div>
<div class="line"><a class="code" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a> nRetVal = pGenerator-&gt;SetMapOutputMode(Mode);</div>
</div><!-- fragment --><h1><a class="anchor" id="device_cpp_grp_setResolutionFps"></a>
'setResolution/Fps()' - Group of Functions for Setting Resolutions and Frame Rates</h1>
<pre class="fragment">    The next functions defined in this file are a group of functions for setting  resolutions and frame rates for all generators in this sample application. All use the methods just defined above, @ref device_cpp_setResolution "setResolution()" and @ref device_cpp_setfps "setFPS()". The code below shows  some examples. 
</pre> <div class="fragment"><div class="line"><span class="keywordtype">void</span> setDepthResolution(<span class="keywordtype">int</span> res)</div>
<div class="line">{</div>
<div class="line">    setResolution(getDepthGenerator(), res);</div>
<div class="line">}</div>
<div class="line">...</div>
<div class="line">...</div>
<div class="line"><span class="keywordtype">void</span> setImageFPS(<span class="keywordtype">int</span> fps)</div>
<div class="line">{</div>
<div class="line">    setFPS(getImageGenerator(), fps);</div>
<div class="line">}</div>
</div><!-- fragment --><p>The 'get' functions used in the above are defined later in this file.</p>
<p>All these 'set resolution/fps' functions are invoked by the user clicking the GUI menu items to make these settings.</p>
<h1><a class="anchor" id="device_cpp_setStreamCropping"></a>
Function: setStreamCropping() - Crops the Map Area of the Generator Output</h1>
<pre class="fragment">    This function crops the map area of the generator output.

    &lt;b&gt;Usage: &lt;/b&gt; For user area selections where the user can use the mouse to select just a part of the full map area for applying OpenNI or other graphic operations.

    &lt;b&gt;Parameters: &lt;/b&gt; 

    &lt;code&gt;pGenerator&lt;/code&gt; - generator node for which to set the cropping area.

    &lt;code&gt;pCropping&lt;/code&gt; -  @ref xn::XnCropping struct containing the cropping details.

    The following statement checks that the generator node exists.
</pre> <div class="fragment"><div class="line"><span class="keywordflow">if</span> (pGenerator == NULL)</div>
<div class="line">{</div>
<div class="line">    displayMessage(<span class="stringliteral">&quot;Stream does not exist!&quot;</span>);</div>
<div class="line">    <span class="keywordflow">return</span>;</div>
<div class="line">}           </div>
</div><!-- fragment --><p>The code first checks that the capability exists using the <a class="el" href="classxn_1_1_production_node.html#a26574447d96527d1a9d79994e550037f">IsCapabilitySupported()</a> method.</p>
<p>The code then gets the crop capability using the <a class="el" href="classxn_1_1_map_generator.html#a123e60e70cfd477f142e2d96eca649fc">GetCroppingCap()</a> method, and through it calls the <a class="el" href="classxn_1_1_cropping_capability.html#a64fc464439faca2a3fbaf2d8c91b517a">xn::CroppingCapability::SetCropping()</a> method.</p>
<h1><a class="anchor" id="device_cpp_setPlaybackSpeed"></a>
Function: setPlaybackSpeed() - Sets the  playback speed</h1>
<pre class="fragment">    &lt;b&gt;Group:&lt;/b&gt;  Recording and Playback 
    {If I want to use this format I will have to go back and make it consistent - ie at least for this sample NiViewer.}

    &lt;b&gt;Parameter:&lt;/b&gt;  ratioDiff - Ratio of recording rate 

    This function sets the playback speed of an OpenNI recording as a ratio of the rate that the recording was made at. This OpenNI recording is a recording of all the actual map data that was generated during the time that recording was enabled. This is not the  same as a production graph stired in an OpenNI XML script file: a script file stores only the structure of the production graph but not the data that the production graph has or will generate.
</pre> <div class="fragment"><div class="line">XnDouble dNewSpeed = g_Player.GetPlaybackSpeed() * pow(2.0, (XnDouble)ratioDiff);</div>
<div class="line"><a class="code" href="_xn_status_8h.html#a23967099202ddb640cd2044b3808253c">XnStatus</a> nRetVal = g_Player.SetPlaybackSpeed(dNewSpeed);</div>
</div><!-- fragment --><h1><a class="anchor" id="device_cpp_getPlaybackSpeed"></a>
Function: getPlaybackSpeed() - Gets the  playback speed</h1>
<pre class="fragment">    &lt;b&gt;Group:&lt;/b&gt;  Recording and Playback 

    This function calls the @ref xn::Player::GetPlaybackSpeed() to get current playback speed. If the player is not valid it returns the "identity' ratio, 1. 
</pre><h1><a class="anchor" id="device_cpp_grp_getobject"></a>
Function: setFPS() - Group of Functions for Setting Resolutions and Frame Rates</h1>
<pre class="fragment">    Next is a group of functions for getting pointers to certain OpenNI objects: to production nodes, generators, and metadata objects. The code below shows some examples. 
    These  functions achieve a way of simply indicating as a boolean flag whether the nodes are actual &lt;i&gt;created&lt;/i&gt; nodes, i.e., whether they have been initialized and made operational in the @ref prod_graph "production graph", or   they are still in the 'pre-creation'  state, i.e., they have been constructed as C++ objects but have not yet undergone creation.
</pre> <div class="fragment"><div class="line">Device* getDevice()</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> g_Device.IsValid() ? &amp;g_Device : NULL;</div>
<div class="line">}</div>
<div class="line">DepthGenerator* getDepthGenerator()</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> g_Depth.IsValid() ? &amp;g_Depth : NULL;</div>
<div class="line">}</div>
<div class="line">...</div>
<div class="line">...</div>
<div class="line"><span class="keyword">const</span> AudioMetaData* getAudioMetaData()</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> g_Audio.IsValid() ? &amp;g_AudioMD : NULL;</div>
<div class="line">}</div>
</div><!-- fragment --> </div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Nov 12 2013 13:40:21 for OpenNI 1.5.7 by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.3.1
</small></address>
</body>
</html>
